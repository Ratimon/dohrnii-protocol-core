{
  "language": "Solidity",
  "sources": {
    "contracts/bondingcurve/BondingCurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./IBondingCurve.sol\";\nimport \"../refs/OracleRef.sol\";\nimport \"../pcv/utils/PCVSplitter.sol\";\nimport \"../utils/Incentivized.sol\";\nimport \"../pcv/IPCVDeposit.sol\";\nimport \"../utils/Timed.sol\";\n\n/**\n * @title a bonding curve for purchasing FEI with ERC-20 tokens\n * @author Fei Protocol\n * \n */ \ncontract BondingCurve is IBondingCurve, OracleRef, PCVSplitter, Timed, Incentivized {\n    using Decimal for Decimal.D256;\n\n    /// @notice the Scale target at which bonding curve price fixes\n    uint256 public override scale;\n\n    /// @notice the ERC20 token for this bonding curve\n    IERC20 public immutable override token;\n\n    /// @notice the total amount of FEI purchased on bonding curve\n    uint256 public override totalPurchased;\n\n    /// @notice the buffer applied on top of the peg purchase price once at Scale\n    uint256 public override buffer;\n    \n    /// @notice the discount applied on top of peg before at Scale\n    uint256 public override discount;\n\n    /// @notice the cap on how much FEI can be minted by the bonding curve\n    uint256 public override mintCap;\n\n    uint256 public constant BASIS_POINTS_GRANULARITY = 10_000;\n\n    /// @notice constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle the price oracle to reference\n    /// @param _backupOracle the backup oracle to reference\n    /// @param _scale the Scale target where peg fixes\n    /// @param _pcvDeposits the PCV Deposits for the PCVSplitter\n    /// @param _ratios the ratios for the PCVSplitter\n    /// @param _duration the duration between incentivizing allocations\n    /// @param _incentive the amount rewarded to the caller of an allocation\n    /// @param _token the ERC20 token associated with this curve, null if ETH\n    /// @param _discount the discount applied to FEI purchases before reaching scale in basis points (1/10000)\n    /// @param _buffer the buffer applied to FEI purchases after reaching scale in basis points (1/10000)\n    constructor(\n        address _core,\n        address _oracle,\n        address _backupOracle,\n        uint256 _scale,\n        address[] memory _pcvDeposits,\n        uint256[] memory _ratios,\n        uint256 _duration,\n        uint256 _incentive,\n        IERC20 _token,\n        uint256 _discount,\n        uint256 _buffer\n    )\n        OracleRef(_core, _oracle, _backupOracle, 0, false)\n        PCVSplitter(_pcvDeposits, _ratios)\n        Timed(_duration)\n        Incentivized(_incentive)\n    {\n        _setMintCap(_scale); // default mint cap is scale\n        _setScale(_scale);\n        token = _token;\n\n        discount = _discount;\n        emit DiscountUpdate(0, _discount);\n\n        buffer = _buffer;\n        emit BufferUpdate(0, _buffer);\n\n        _initTimed();\n\n        if (address(_token) != address(0)) {\n            _setDecimalsNormalizerFromToken(address(_token));\n        }\n    }\n\n    /// @notice purchase FEI for underlying tokens\n    /// @param to address to receive FEI\n    /// @param amountIn amount of underlying tokens input\n    /// @return amountOut amount of FEI received\n    function purchase(address to, uint256 amountIn)\n        external\n        payable\n        virtual\n        override\n        whenNotPaused\n        returns (uint256 amountOut)\n    {\n        require(msg.value == 0, \"BondingCurve: unexpected ETH input\");\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), amountIn);\n        return _purchase(amountIn, to);\n    }\n\n    /// @notice balance of the bonding curve\n    /// @return the amount of PCV held in contract and ready to be allocated\n    function balance() public view virtual override returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice sets the bonding curve Scale target\n    function setScale(uint256 newScale) external override onlyGovernorOrAdmin {\n        _setScale(newScale);\n    }\n\n    /// @notice resets the totalPurchased\n    function reset() external override onlyGovernorOrAdmin {\n        uint256 oldTotalPurchased = totalPurchased;\n        totalPurchased = 0;\n        emit Reset(oldTotalPurchased);\n    }\n\n    /// @notice sets the bonding curve price buffer\n    function setBuffer(uint256 newBuffer) external override onlyGovernorOrAdmin {\n        require(\n            newBuffer < BASIS_POINTS_GRANULARITY,\n            \"BondingCurve: Buffer exceeds or matches granularity\"\n        );\n        uint256 oldBuffer = buffer;\n        buffer = newBuffer;\n        emit BufferUpdate(oldBuffer, newBuffer);\n    }\n\n    /// @notice sets the bonding curve price discount\n    function setDiscount(uint256 newDiscount) external override onlyGovernorOrAdmin {\n        require(\n            newDiscount < BASIS_POINTS_GRANULARITY,\n            \"BondingCurve: Buffer exceeds or matches granularity\"\n        );\n        uint256 oldDiscount = discount;\n        discount = newDiscount;\n        emit DiscountUpdate(oldDiscount, newDiscount);\n    }\n\n    /// @notice sets the allocate incentive frequency\n    function setIncentiveFrequency(uint256 _frequency) external override onlyGovernorOrAdmin {\n        _setDuration(_frequency);\n    }\n\n    /// @notice sets the mint cap for the bonding curve\n    function setMintCap(uint256 _mintCap) external override onlyGovernorOrAdmin {\n        _setMintCap(_mintCap);\n    }\n\n    /// @notice sets the allocation of incoming PCV\n    function setAllocation(\n        address[] calldata allocations,\n        uint256[] calldata ratios\n    ) external override onlyGovernor {\n        _setAllocation(allocations, ratios);\n    }\n\n    /// @notice batch allocate held PCV\n    function allocate() external override whenNotPaused {\n        uint256 amount = balance();\n        uint256 usdValueHeld = readOracle().mul(amount).asUint256();\n        // the premium is the USD value held multiplied by the buffer that a user would pay to get FEI assuming FEI is $1\n        uint256 premium = usdValueHeld * buffer / BASIS_POINTS_GRANULARITY;\n\n        // this requirement mitigates gaming the allocate function and ensures it is only called when sufficient demand has been met\n        require(premium >= incentiveAmount, \"BondingCurve: Not enough PCV held\");\n\n        _allocate(amount);\n\n        // if window has passed, reward caller and reset window\n        if (isTimeEnded()) {\n            _initTimed(); // reset window\n            _incentivize();\n        }\n\n        emit Allocate(msg.sender, amount);\n    }\n\n    /// @notice a boolean signalling whether Scale has been reached\n    function atScale() public view override returns (bool) {\n        return totalPurchased >= scale;\n    }\n\n    /// @notice returns how close to the minting cap we are\n    function availableToMint() public view override returns (uint256) {\n        return mintCap - totalPurchased;\n    }\n\n    /// @notice return current instantaneous bonding curve price\n    /// @return price reported as FEI per USD\n    /// @dev Can be inaccurate if outdated, need to call `oracle().isOutdated()` to check\n    function getCurrentPrice()\n        public\n        view\n        override\n        returns (Decimal.D256 memory)\n    {\n        if (atScale()) {\n            return _getBufferMultiplier();\n        }\n        return _getBondingCurvePriceMultiplier();\n    }\n\n    /// @notice return amount of FEI received after a bonding curve purchase\n    /// @param amountIn the amount of underlying used to purchase\n    /// @return amountOut the amount of FEI received\n    /// @dev Can be innacurate if outdated, need to call `oracle().isOutdated()` to check\n    function getAmountOut(uint256 amountIn)\n        public\n        view\n        override\n        returns (uint256 amountOut)\n    {\n        // the FEI value of the input amount\n        uint256 feiValueOfAmountIn = readOracle().mul(amountIn).asUint256();\n\n        Decimal.D256 memory price = getCurrentPrice();\n\n        if (!atScale()) {\n            uint256 preScaleAmount = scale - totalPurchased;\n\n            // crossing scale\n            if (feiValueOfAmountIn > preScaleAmount) {\n                uint256 postScaleAmount = feiValueOfAmountIn - preScaleAmount;\n                // combined pricing of pre-scale price times the amount to reach scale and post-scale price times remainder\n                return price.mul(preScaleAmount).add(_getBufferMultiplier().mul(postScaleAmount)).asUint256();\n            }\n        }\n\n        amountOut = price.mul(feiValueOfAmountIn).asUint256();\n    }\n\n    /// @notice mint FEI and send to buyer destination\n    function _purchase(uint256 amountIn, address to)\n        internal\n        returns (uint256 amountOut)\n    {\n        updateOracle();\n\n        amountOut = getAmountOut(amountIn);\n\n        require(availableToMint() >= amountOut, \"BondingCurve: exceeds mint cap\");\n\n        _incrementTotalPurchased(amountOut);\n        fei().mint(to, amountOut);\n\n        emit Purchase(to, amountIn, amountOut);\n\n        return amountOut;\n    }\n\n    function _incrementTotalPurchased(uint256 amount) internal {\n        totalPurchased = totalPurchased + amount;\n    }\n\n    function _setScale(uint256 newScale) internal {\n        require(newScale != 0, \"BondingCurve: zero scale\");\n\n        uint256 oldScale = scale;\n        scale = newScale;\n        emit ScaleUpdate(oldScale, newScale);\n    }\n\n    function _setMintCap(uint256 newMintCap) internal {\n        require(newMintCap != 0, \"BondingCurve: zero mint cap\");\n\n        uint256 oldMintCap = mintCap;\n        mintCap = newMintCap;\n\n        emit MintCapUpdate(oldMintCap, newMintCap);\n    }\n\n    /// @notice the bonding curve price multiplier used before Scale\n    function _getBondingCurvePriceMultiplier()\n        internal\n        view\n        virtual\n        returns (Decimal.D256 memory)\n    {\n        uint256 granularity = BASIS_POINTS_GRANULARITY;\n        // uses 1/1-b because the oracle price is inverted\n        return Decimal.ratio(granularity, granularity - discount);\n    }\n\n    /// @notice returns the buffer on the post-scale bonding curve price\n    function _getBufferMultiplier() internal view returns (Decimal.D256 memory) {\n        uint256 granularity = BASIS_POINTS_GRANULARITY;\n        // uses 1/1+b because the oracle price is inverted\n        return Decimal.ratio(granularity, granularity + buffer);\n    }\n\n    // Allocates a portion of escrowed PCV to a target PCV deposit\n    function _allocateSingle(uint256 amount, address pcvDeposit)\n        internal\n        virtual\n        override\n    {\n        SafeERC20.safeTransfer(token, pcvDeposit, amount);\n        IPCVDeposit(pcvDeposit).deposit();\n    }\n}\n"
    },
    "contracts/openzeppelin/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    },
    "contracts/bondingcurve/IBondingCurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../external/Decimal.sol\";\nimport \"../openzeppelin/token/ERC20/IERC20.sol\";\n\ninterface IBondingCurve {\n    // ----------- Events -----------\n\n    event ScaleUpdate(uint256 oldScale, uint256 newScale);\n\n    event MintCapUpdate(uint256 oldMint, uint256 newMint);\n\n    event BufferUpdate(uint256 oldBuffer, uint256 newBuffer);\n\n    event DiscountUpdate(uint256 oldDiscount, uint256 newDiscount);\n\n    event Purchase(address indexed to, uint256 amountIn, uint256 amountOut);\n\n    event Allocate(address indexed caller, uint256 amount);\n\n    event Reset(uint256 oldTotalPurchased);\n    \n    // ----------- State changing Api -----------\n\n    function purchase(address to, uint256 amountIn)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    function allocate() external;\n\n    // ----------- Governor only state changing api -----------\n\n    function reset() external;\n\n    function setBuffer(uint256 newBuffer) external;\n\n    function setDiscount(uint256 newDiscount) external;\n\n    function setScale(uint256 newScale) external;\n\n    function setAllocation(\n        address[] calldata pcvDeposits,\n        uint256[] calldata ratios\n    ) external;\n\n    function setIncentiveFrequency(uint256 newFrequency) external;\n\n    function setMintCap(uint256 newMintCap) external;\n\n    // ----------- Getters -----------\n\n    function getCurrentPrice() external view returns (Decimal.D256 memory);\n\n    function getAmountOut(uint256 amountIn)\n        external\n        view\n        returns (uint256 amountOut);\n\n    function scale() external view returns (uint256);\n\n    function atScale() external view returns (bool);\n\n    function buffer() external view returns (uint256);\n\n    function discount() external view returns (uint256);\n\n    function totalPurchased() external view returns (uint256);\n\n    function balance() external view returns (uint256);\n\n    function token() external view returns (IERC20);\n\n    function mintCap() external view returns (uint256);\n\n    function availableToMint() external view returns (uint256);\n}\n"
    },
    "contracts/refs/OracleRef.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./IOracleRef.sol\";\nimport \"./CoreRef.sol\";\nimport \"../openzeppelin/utils/math/SafeCast.sol\";\nimport \"../openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @title Reference to an Oracle\n/// @author Fei Protocol\n/// @notice defines some utilities around interacting with the referenced oracle\nabstract contract OracleRef is IOracleRef, CoreRef {\n    using Decimal for Decimal.D256;\n    using SafeCast for int256;\n\n    /// @notice the oracle reference by the contract\n    IOracle public override oracle;\n\n    /// @notice the backup oracle reference by the contract\n    IOracle public override backupOracle;\n\n    /// @notice number of decimals to scale oracle price by, i.e. multiplying by 10^(decimalsNormalizer)\n    int256 public override decimalsNormalizer;\n\n    bool public override doInvert;\n\n    /// @notice OracleRef constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle oracle to reference\n    /// @param _backupOracle backup oracle to reference\n    /// @param _decimalsNormalizer number of decimals to normalize the oracle feed if necessary\n    /// @param _doInvert invert the oracle price if this flag is on\n    constructor(address _core, address _oracle, address _backupOracle, int256 _decimalsNormalizer, bool _doInvert) CoreRef(_core) {\n        _setOracle(_oracle);\n        if (_backupOracle != address(0) && _backupOracle != _oracle) {\n            _setBackupOracle(_backupOracle);\n        }\n        _setDoInvert(_doInvert);\n        _setDecimalsNormalizer(_decimalsNormalizer);\n    }\n\n    /// @notice sets the referenced oracle\n    /// @param newOracle the new oracle to reference\n    function setOracle(address newOracle) external override onlyGovernor {\n        _setOracle(newOracle);\n    }\n\n    /// @notice sets the flag for whether to invert or not\n    /// @param newDoInvert the new flag for whether to invert\n    function setDoInvert(bool newDoInvert) external override onlyGovernor {\n        _setDoInvert(newDoInvert);\n    }\n\n    /// @notice sets the new decimalsNormalizer\n    /// @param newDecimalsNormalizer the new decimalsNormalizer\n    function setDecimalsNormalizer(int256 newDecimalsNormalizer) external override onlyGovernor {\n        _setDecimalsNormalizer(newDecimalsNormalizer);\n    }\n    /// @notice sets the referenced backup oracle\n    /// @param newBackupOracle the new backup oracle to reference\n    function setBackupOracle(address newBackupOracle) external override onlyGovernor {\n        _setBackupOracle(newBackupOracle);\n    }\n\n    /// @notice invert a peg price\n    /// @param price the peg price to invert\n    /// @return the inverted peg as a Decimal\n    /// @dev the inverted peg would be X per FEI\n    function invert(Decimal.D256 memory price)\n        public\n        pure\n        override\n        returns (Decimal.D256 memory)\n    {\n        return Decimal.one().div(price);\n    }\n\n    /// @notice updates the referenced oracle\n    function updateOracle() public override {\n        oracle.update();\n    }\n\n    /// @notice the peg price of the referenced oracle\n    /// @return the peg as a Decimal\n    /// @dev the peg is defined as FEI per X with X being ETH, dollars, etc\n    function readOracle() public view override returns (Decimal.D256 memory) {\n        (Decimal.D256 memory _peg, bool valid) = oracle.read();\n        if (!valid && address(backupOracle) != address(0)) {\n            (_peg, valid) = backupOracle.read();\n        }\n        require(valid, \"OracleRef: oracle invalid\");\n\n        // Scale the oracle price by token decimals delta if necessary\n        uint256 scalingFactor;\n        if (decimalsNormalizer < 0) {\n            scalingFactor = 10 ** (-1 * decimalsNormalizer).toUint256();\n            _peg = _peg.div(scalingFactor);\n        } else {\n            scalingFactor = 10 ** decimalsNormalizer.toUint256();\n            _peg = _peg.mul(scalingFactor);\n        }\n\n        // Invert the oracle price if necessary\n        if (doInvert) {\n            _peg = invert(_peg);\n        }\n        return _peg;\n    }\n\n    function _setOracle(address newOracle) internal {\n        require(newOracle != address(0), \"OracleRef: zero address\");\n        address oldOracle = address(oracle);\n        oracle = IOracle(newOracle);\n        emit OracleUpdate(oldOracle, newOracle);\n    }\n\n    // Supports zero address if no backup\n    function _setBackupOracle(address newBackupOracle) internal {\n        address oldBackupOracle = address(backupOracle);\n        backupOracle = IOracle(newBackupOracle);\n        emit BackupOracleUpdate(oldBackupOracle, newBackupOracle);\n    }\n\n    function _setDoInvert(bool newDoInvert) internal {\n        bool oldDoInvert = doInvert;\n        doInvert = newDoInvert;\n        \n        if (oldDoInvert != newDoInvert) {\n            _setDecimalsNormalizer( -1 * decimalsNormalizer);\n        }\n\n        emit InvertUpdate(oldDoInvert, newDoInvert);\n    }\n\n    function _setDecimalsNormalizer(int256 newDecimalsNormalizer) internal {\n        int256 oldDecimalsNormalizer = decimalsNormalizer;\n        decimalsNormalizer = newDecimalsNormalizer;\n        emit DecimalsNormalizerUpdate(oldDecimalsNormalizer, newDecimalsNormalizer);\n    }\n\n    function _setDecimalsNormalizerFromToken(address token) internal {\n        int256 feiDecimals = 18;\n        int256 _decimalsNormalizer = feiDecimals - int256(uint256(IERC20Metadata(token).decimals()));\n        \n        if (doInvert) {\n            _decimalsNormalizer = -1 * _decimalsNormalizer;\n        }\n        \n        _setDecimalsNormalizer(_decimalsNormalizer);\n    }\n}\n"
    },
    "contracts/pcv/utils/PCVSplitter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\n/// @title abstract contract for splitting PCV into different deposits\n/// @author Fei Protocol\nabstract contract PCVSplitter {\n\n    /// @notice total allocation allowed representing 100%\n    uint256 public constant ALLOCATION_GRANULARITY = 10_000;\n\n    uint256[] private ratios;\n    address[] private pcvDeposits;\n\n    event AllocationUpdate(address[] oldPCVDeposits, uint256[] oldRatios, address[] newPCVDeposits, uint256[] newRatios);\n\n    /// @notice PCVSplitter constructor\n    /// @param _pcvDeposits list of PCV Deposits to split to\n    /// @param _ratios ratios for splitting PCV Deposit allocations\n    constructor(address[] memory _pcvDeposits, uint256[] memory _ratios) {\n        _setAllocation(_pcvDeposits, _ratios);\n    }\n\n    /// @notice make sure an allocation has matching lengths and totals the ALLOCATION_GRANULARITY\n    /// @param _pcvDeposits new list of pcv deposits to send to\n    /// @param _ratios new ratios corresponding to the PCV deposits\n    function checkAllocation(\n        address[] memory _pcvDeposits,\n        uint256[] memory _ratios\n    ) public pure {\n        require(\n            _pcvDeposits.length == _ratios.length,\n            \"PCVSplitter: PCV Deposits and ratios are different lengths\"\n        );\n\n        uint256 total;\n        for (uint256 i; i < _ratios.length; i++) {\n            total = total + _ratios[i];\n        }\n\n        require(\n            total == ALLOCATION_GRANULARITY,\n            \"PCVSplitter: ratios do not total 100%\"\n        );\n    }\n\n    /// @notice gets the pcvDeposits and ratios of the splitter\n    function getAllocation()\n        public\n        view\n        returns (address[] memory, uint256[] memory)\n    {\n        return (pcvDeposits, ratios);\n    }\n\n    /// @notice distribute funds to single PCV deposit\n    /// @param amount amount of funds to send\n    /// @param pcvDeposit the pcv deposit to send funds\n    function _allocateSingle(uint256 amount, address pcvDeposit)\n        internal\n        virtual;\n\n    /// @notice sets a new allocation for the splitter\n    /// @param _pcvDeposits new list of pcv deposits to send to\n    /// @param _ratios new ratios corresponding to the PCV deposits. Must total ALLOCATION_GRANULARITY\n    function _setAllocation(\n        address[] memory _pcvDeposits,\n        uint256[] memory _ratios\n    ) internal {\n        address[] memory _oldPCVDeposits = pcvDeposits;\n        uint256[] memory _oldRatios = ratios;\n\n        checkAllocation(_pcvDeposits, _ratios);\n\n        pcvDeposits = _pcvDeposits;\n        ratios = _ratios;\n\n        emit AllocationUpdate(_oldPCVDeposits, _oldRatios, _pcvDeposits, _ratios);\n    }\n\n    /// @notice distribute funds to all pcv deposits at specified allocation ratios\n    /// @param total amount of funds to send\n    function _allocate(uint256 total) internal {\n        uint256 granularity = ALLOCATION_GRANULARITY;\n        for (uint256 i; i < ratios.length; i++) {\n            uint256 amount = total * ratios[i] / granularity;\n            _allocateSingle(amount, pcvDeposits[i]);\n        }\n    }\n}\n"
    },
    "contracts/utils/Incentivized.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../refs/CoreRef.sol\";\n\n/// @title abstract contract for incentivizing keepers\n/// @author Fei Protocol\nabstract contract Incentivized is CoreRef {\n\n    /// @notice FEI incentive for calling keeper functions\n    uint256 public incentiveAmount;\n\n    event IncentiveUpdate(uint256 oldIncentiveAmount, uint256 newIncentiveAmount);\n\n    constructor(uint256 _incentiveAmount) {\n        incentiveAmount = _incentiveAmount;\n        emit IncentiveUpdate(0, _incentiveAmount);\n    }\n\n    /// @notice set the incentiveAmount\n    function setIncentiveAmount(uint256 newIncentiveAmount) public onlyGovernor {\n        uint256 oldIncentiveAmount = incentiveAmount;\n        incentiveAmount = newIncentiveAmount;\n        emit IncentiveUpdate(oldIncentiveAmount, newIncentiveAmount);\n    }\n\n    /// @notice incentivize a call with incentiveAmount FEI rewards\n    /// @dev no-op if the contract does not have Minter role\n    function _incentivize() internal ifMinterSelf {\n        fei().mint(msg.sender, incentiveAmount);\n    }\n}\n"
    },
    "contracts/pcv/IPCVDeposit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\n/// @title a PCV Deposit interface\n/// @author Fei Protocol\ninterface IPCVDeposit {\n    // ----------- Events -----------\n    event Deposit(address indexed _from, uint256 _amount);\n\n    event Withdrawal(\n        address indexed _caller,\n        address indexed _to,\n        uint256 _amount\n    );\n\n    event WithdrawERC20(\n        address indexed _caller,\n        address indexed _token,\n        address indexed _to,\n        uint256 _amount\n    );\n\n    event WithdrawETH(\n        address indexed _caller,\n        address indexed _to,\n        uint256 _amount\n    );\n\n    // ----------- State changing api -----------\n\n    function deposit() external;\n\n    // ----------- PCV Controller only state changing api -----------\n\n    function withdraw(address to, uint256 amount) external;\n\n    function withdrawERC20(address token, address to, uint256 amount) external;\n\n    function withdrawETH(address payable to, uint256 amount) external;\n    \n    // ----------- Getters -----------\n\n    function balance() external view returns (uint256);\n}\n"
    },
    "contracts/utils/Timed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\n/// @title an abstract contract for timed events\n/// @author Fei Protocol\nabstract contract Timed {\n\n    /// @notice the start timestamp of the timed period\n    uint256 public startTime;\n\n    /// @notice the duration of the timed period\n    uint256 public duration;\n\n    event DurationUpdate(uint256 oldDuration, uint256 newDuration);\n\n    event TimerReset(uint256 startTime);\n\n    constructor(uint256 _duration) {\n        _setDuration(_duration);\n    }\n\n    modifier duringTime() {\n        require(isTimeStarted(), \"Timed: time not started\");\n        require(!isTimeEnded(), \"Timed: time ended\");\n        _;\n    }\n\n    modifier afterTime() {\n        require(isTimeEnded(), \"Timed: time not ended\");\n        _;\n    }\n\n    /// @notice return true if time period has ended\n    function isTimeEnded() public view returns (bool) {\n        return remainingTime() == 0;\n    }\n\n    /// @notice number of seconds remaining until time is up\n    /// @return remaining\n    function remainingTime() public view returns (uint256) {\n        return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]\n    }\n\n    /// @notice number of seconds since contract was initialized\n    /// @return timestamp\n    /// @dev will be less than or equal to duration\n    function timeSinceStart() public view returns (uint256) {\n        if (!isTimeStarted()) {\n            return 0; // uninitialized\n        }\n        uint256 _duration = duration;\n        uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime\n        return timePassed > _duration ? _duration : timePassed;\n    }\n\n    function isTimeStarted() public view returns (bool) {\n        return startTime != 0;\n    }\n\n    function _initTimed() internal {\n        startTime = block.timestamp;\n        \n        emit TimerReset(block.timestamp);\n    }\n\n    function _setDuration(uint256 newDuration) internal {\n        require(newDuration != 0, \"Timed: zero duration\");\n\n        uint256 oldDuration = duration;\n        duration = newDuration;\n        emit DurationUpdate(oldDuration, newDuration);\n    }\n}\n"
    },
    "contracts/openzeppelin/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/openzeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/external/Decimal.sol": {
      "content": "/*\n    Copyright 2019 dYdX Trading Inc.\n    Copyright 2020 Empty Set Squad <emptysetsquad@protonmail.com>\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\npragma solidity ^0.8.4;\n\nimport \"../openzeppelin/utils/math/SafeMath.sol\";\n\n/**\n * @title Decimal\n * @author dYdX\n *\n * Library that defines a fixed-point number with 18 decimal places.\n */\nlibrary Decimal {\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 private constant BASE = 10**18;\n\n    // ============ Structs ============\n\n\n    struct D256 {\n        uint256 value;\n    }\n\n    // ============ Static Functions ============\n\n    function zero()\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: 0 });\n    }\n\n    function one()\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: BASE });\n    }\n\n    function from(\n        uint256 a\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: a.mul(BASE) });\n    }\n\n    function ratio(\n        uint256 a,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: getPartial(a, BASE, b) });\n    }\n\n    // ============ Self Functions ============\n\n    function add(\n        D256 memory self,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.add(b.mul(BASE)) });\n    }\n\n    function sub(\n        D256 memory self,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.sub(b.mul(BASE)) });\n    }\n\n    function sub(\n        D256 memory self,\n        uint256 b,\n        string memory reason\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.sub(b.mul(BASE), reason) });\n    }\n\n    function mul(\n        D256 memory self,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.mul(b) });\n    }\n\n    function div(\n        D256 memory self,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.div(b) });\n    }\n\n    function pow(\n        D256 memory self,\n        uint256 b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        if (b == 0) {\n            return from(1);\n        }\n\n        D256 memory temp = D256({ value: self.value });\n        for (uint256 i = 1; i < b; i++) {\n            temp = mul(temp, self);\n        }\n\n        return temp;\n    }\n\n    function add(\n        D256 memory self,\n        D256 memory b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.add(b.value) });\n    }\n\n    function sub(\n        D256 memory self,\n        D256 memory b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.sub(b.value) });\n    }\n\n    function sub(\n        D256 memory self,\n        D256 memory b,\n        string memory reason\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: self.value.sub(b.value, reason) });\n    }\n\n    function mul(\n        D256 memory self,\n        D256 memory b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: getPartial(self.value, b.value, BASE) });\n    }\n\n    function div(\n        D256 memory self,\n        D256 memory b\n    )\n    internal\n    pure\n    returns (D256 memory)\n    {\n        return D256({ value: getPartial(self.value, BASE, b.value) });\n    }\n\n    function equals(D256 memory self, D256 memory b) internal pure returns (bool) {\n        return self.value == b.value;\n    }\n\n    function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {\n        return compareTo(self, b) == 2;\n    }\n\n    function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {\n        return compareTo(self, b) == 0;\n    }\n\n    function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\n        return compareTo(self, b) > 0;\n    }\n\n    function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\n        return compareTo(self, b) < 2;\n    }\n\n    function isZero(D256 memory self) internal pure returns (bool) {\n        return self.value == 0;\n    }\n\n    function asUint256(D256 memory self) internal pure returns (uint256) {\n        return self.value.div(BASE);\n    }\n\n    // ============ Core Methods ============\n\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n    private\n    pure\n    returns (uint256)\n    {\n        return target.mul(numerator).div(denominator);\n    }\n\n    function compareTo(\n        D256 memory a,\n        D256 memory b\n    )\n    private\n    pure\n    returns (uint256)\n    {\n        if (a.value == b.value) {\n            return 1;\n        }\n        return a.value > b.value ? 2 : 0;\n    }\n}"
    },
    "contracts/openzeppelin/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}"
    },
    "contracts/refs/IOracleRef.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../oracle/IOracle.sol\";\n\n/// @title OracleRef interface\n/// @author Fei Protocol\ninterface IOracleRef {\n    // ----------- Events -----------\n\n    event OracleUpdate(address indexed oldOracle, address indexed newOracle);\n\n    event InvertUpdate(bool oldDoInvert, bool newDoInvert);\n\n    event DecimalsNormalizerUpdate(int256 oldDecimalsNormalizer, int256 newDecimalsNormalizer);\n\n    event BackupOracleUpdate(address indexed oldBackupOracle, address indexed newBackupOracle);\n\n\n    // ----------- State changing API -----------\n\n    function updateOracle() external;\n\n    // ----------- Governor only state changing API -----------\n\n    function setOracle(address newOracle) external;\n\n    function setBackupOracle(address newBackupOracle) external;\n\n    function setDecimalsNormalizer(int256 newDecimalsNormalizer) external;\n\n    function setDoInvert(bool newDoInvert) external;\n\n    // ----------- Getters -----------\n\n    function oracle() external view returns (IOracle);\n\n    function backupOracle() external view returns (IOracle);\n\n    function doInvert() external view returns (bool);\n\n    function decimalsNormalizer() external view returns (int256);\n\n    function readOracle() external view returns (Decimal.D256 memory);\n\n    function invert(Decimal.D256 calldata price)\n        external\n        pure\n        returns (Decimal.D256 memory);\n}\n"
    },
    "contracts/refs/CoreRef.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./ICoreRef.sol\";\nimport \"../openzeppelin/security/Pausable.sol\";\n\n/// @title A Reference to Core\n/// @author Fei Protocol\n/// @notice defines some modifiers and utilities around interacting with Core\nabstract contract CoreRef is ICoreRef, Pausable {\n    ICore private _core;\n\n    /// @notice a role used with a subset of governor permissions for this contract only\n    bytes32 public override CONTRACT_ADMIN_ROLE;\n\n    /// @notice boolean to check whether or not the contract has been initialized.\n    /// cannot be initialized twice.\n    bool private _initialized;\n\n    constructor(address coreAddress) {\n        _initialize(coreAddress);\n    }\n\n    /// @notice CoreRef constructor\n    /// @param coreAddress Fei Core to reference\n    function _initialize(address coreAddress) internal {\n        require(!_initialized, \"CoreRef: already initialized\");\n        _initialized = true;\n\n        _core = ICore(coreAddress);\n        _setContractAdminRole(_core.GOVERN_ROLE());\n    }\n\n    modifier ifMinterSelf() {\n        if (_core.isMinter(address(this))) {\n            _;\n        }\n    }\n\n    modifier onlyMinter() {\n        require(_core.isMinter(msg.sender), \"CoreRef: Caller is not a minter\");\n        _;\n    }\n\n    modifier onlyBurner() {\n        require(_core.isBurner(msg.sender), \"CoreRef: Caller is not a burner\");\n        _;\n    }\n\n    modifier onlyPCVController() {\n        require(\n            _core.isPCVController(msg.sender),\n            \"CoreRef: Caller is not a PCV controller\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrAdmin() {\n        require(\n            _core.isGovernor(msg.sender) ||\n            isContractAdmin(msg.sender),\n            \"CoreRef: Caller is not a governor or contract admin\"\n        );\n        _;\n    }\n\n    modifier onlyGovernor() {\n        require(\n            _core.isGovernor(msg.sender),\n            \"CoreRef: Caller is not a governor\"\n        );\n        _;\n    }\n\n    modifier onlyGuardianOrGovernor() {\n        require(\n            _core.isGovernor(msg.sender) || \n            _core.isGuardian(msg.sender),\n            \"CoreRef: Caller is not a guardian or governor\"\n        );\n        _;\n    }\n\n    modifier onlyFei() {\n        require(msg.sender == address(fei()), \"CoreRef: Caller is not FEI\");\n        _;\n    }\n\n    /// @notice set new Core reference address\n    /// @param newCore the new core address\n    function setCore(address newCore) external override onlyGovernor {\n        require(newCore != address(0), \"CoreRef: zero address\");\n        address oldCore = address(_core);\n        _core = ICore(newCore);\n        emit CoreUpdate(oldCore, newCore);\n    }\n\n    /// @notice sets a new admin role for this contract\n    function setContractAdminRole(bytes32 newContractAdminRole) external override onlyGovernor {\n        _setContractAdminRole(newContractAdminRole);\n    }\n\n    /// @notice returns whether a given address has the admin role for this contract\n    function isContractAdmin(address _admin) public view override returns (bool) {\n        return _core.hasRole(CONTRACT_ADMIN_ROLE, _admin);\n    }\n\n    /// @notice set pausable methods to paused\n    function pause() public override onlyGuardianOrGovernor {\n        _pause();\n    }\n\n    /// @notice set pausable methods to unpaused\n    function unpause() public override onlyGuardianOrGovernor {\n        _unpause();\n    }\n\n    /// @notice address of the Core contract referenced\n    /// @return ICore implementation address\n    function core() public view override returns (ICore) {\n        return _core;\n    }\n\n    /// @notice address of the Fei contract referenced by Core\n    /// @return IFei implementation address\n    function fei() public view override returns (IFei) {\n        return _core.fei();\n    }\n\n    /// @notice address of the Tribe contract referenced by Core\n    /// @return IERC20 implementation address\n    function tribe() public view override returns (IERC20) {\n        return _core.tribe();\n    }\n\n    /// @notice fei balance of contract\n    /// @return fei amount held\n    function feiBalance() public view override returns (uint256) {\n        return fei().balanceOf(address(this));\n    }\n\n    /// @notice tribe balance of contract\n    /// @return tribe amount held\n    function tribeBalance() public view override returns (uint256) {\n        return tribe().balanceOf(address(this));\n    }\n\n    function _burnFeiHeld() internal {\n        fei().burn(feiBalance());\n    }\n\n    function _mintFei(uint256 amount) internal {\n        fei().mint(address(this), amount);\n    }\n\n    function _setContractAdminRole(bytes32 newContractAdminRole) internal {\n        bytes32 oldContractAdminRole = CONTRACT_ADMIN_ROLE;\n        CONTRACT_ADMIN_ROLE = newContractAdminRole;\n        emit ContractAdminRoleUpdate(oldContractAdminRole, newContractAdminRole);\n    }\n}\n"
    },
    "contracts/openzeppelin/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}"
    },
    "contracts/openzeppelin/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/oracle/IOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../external/Decimal.sol\";\n\n/// @title generic oracle interface for Fei Protocol\n/// @author Fei Protocol\ninterface IOracle {\n    // ----------- Events -----------\n\n    event Update(uint256 _peg);\n\n    // ----------- State changing API -----------\n\n    function update() external;\n\n    // ----------- Getters -----------\n\n    function read() external view returns (Decimal.D256 memory, bool);\n\n    function isOutdated() external view returns (bool);\n    \n}\n"
    },
    "contracts/refs/ICoreRef.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../core/ICore.sol\";\n\n/// @title CoreRef interface\n/// @author Fei Protocol\ninterface ICoreRef {\n    // ----------- Events -----------\n\n    event CoreUpdate(address indexed oldCore, address indexed newCore);\n\n    event ContractAdminRoleUpdate(bytes32 indexed oldContractAdminRole, bytes32 indexed newContractAdminRole);\n\n    // ----------- Governor only state changing api -----------\n\n    function setCore(address newCore) external;\n\n    function setContractAdminRole(bytes32 newContractAdminRole) external;\n\n    // ----------- Governor or Guardian only state changing api -----------\n\n    function pause() external;\n\n    function unpause() external;\n\n    // ----------- Getters -----------\n\n    function core() external view returns (ICore);\n\n    function fei() external view returns (IFei);\n\n    function tribe() external view returns (IERC20);\n\n    function feiBalance() external view returns (uint256);\n\n    function tribeBalance() external view returns (uint256);\n\n    function CONTRACT_ADMIN_ROLE() external view returns (bytes32);\n\n    function isContractAdmin(address admin) external view returns (bool);\n}\n"
    },
    "contracts/openzeppelin/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/core/ICore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./IPermissions.sol\";\nimport \"../token/IFei.sol\";\n\n/// @title Core Interface\n/// @author Fei Protocol\ninterface ICore is IPermissions {\n    // ----------- Events -----------\n\n    event FeiUpdate(address indexed _fei);\n    event TribeUpdate(address indexed _tribe);\n    event GenesisGroupUpdate(address indexed _genesisGroup);\n    event TribeAllocation(address indexed _to, uint256 _amount);\n    event GenesisPeriodComplete(uint256 _timestamp);\n\n    // ----------- Governor only state changing api -----------\n\n    function init(address _fei, address _trib) external;\n\n    // ----------- Governor only state changing api -----------\n\n    function setFei(address token) external;\n\n    function setTribe(address token) external;\n\n    function allocateTribe(address to, uint256 amount) external;\n\n    // ----------- Getters -----------\n\n    function fei() external view returns (IFei);\n\n    function tribe() external view returns (IERC20);\n}\n"
    },
    "contracts/core/IPermissions.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../openzeppelin/access/AccessControl.sol\";\n\n\n/// @title Permissions interface\n/// @author Fei Protocol\ninterface IPermissions is IAccessControl {\n    // ----------- Governor only state changing api -----------\n\n    function createRole(bytes32 role, bytes32 adminRole) external;\n\n    function grantMinter(address minter) external;\n\n    function grantBurner(address burner) external;\n\n    function grantPCVController(address pcvController) external;\n\n    function grantGovernor(address governor) external;\n\n    function grantGuardian(address guardian) external;\n\n    function revokeMinter(address minter) external;\n\n    function revokeBurner(address burner) external;\n\n    function revokePCVController(address pcvController) external;\n\n    function revokeGovernor(address governor) external;\n\n    function revokeGuardian(address guardian) external;\n\n    // ----------- Revoker only state changing api -----------\n\n    function revokeOverride(bytes32 role, address account) external;\n\n    // ----------- Getters -----------\n\n    function isBurner(address _address) external view returns (bool);\n\n    function isMinter(address _address) external view returns (bool);\n\n    function isGovernor(address _address) external view returns (bool);\n\n    function isGuardian(address _address) external view returns (bool);\n\n    function isPCVController(address _address) external view returns (bool);\n\n    function GUARDIAN_ROLE() external view returns (bytes32);\n\n    function GOVERN_ROLE() external view returns (bytes32);\n\n    function BURNER_ROLE() external view returns (bytes32);\n\n    function MINTER_ROLE() external view returns (bytes32);\n\n    function PCV_CONTROLLER_ROLE() external view returns (bytes32);\n\n}\n"
    },
    "contracts/token/IFei.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../openzeppelin/token/ERC20/IERC20.sol\";\n\n\n/// @title FEI stablecoin interface\n/// @author Fei Protocol\ninterface IFei is IERC20 {\n    // ----------- Events -----------\n\n    event Minting(\n        address indexed _to,\n        address indexed _minter,\n        uint256 _amount\n    );\n\n    event Burning(\n        address indexed _to,\n        address indexed _burner,\n        uint256 _amount\n    );\n\n    event IncentiveContractUpdate(\n        address indexed _incentivized,\n        address indexed _incentiveContract\n    );\n\n    // ----------- State changing api -----------\n\n    function burn(uint256 amount) external;\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    // ----------- Burner only state changing api -----------\n\n    function burnFrom(address account, uint256 amount) external;\n\n    // ----------- Minter only state changing api -----------\n\n    function mint(address account, uint256 amount) external;\n\n    // ----------- Governor only state changing api -----------\n\n    function setIncentiveContract(address account, address incentive) external;\n\n    // ----------- Getters -----------\n\n    function incentiveContract(address account) external view returns (address);\n}\n"
    },
    "contracts/openzeppelin/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}"
    },
    "contracts/openzeppelin/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}"
    },
    "contracts/openzeppelin/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/openzeppelin/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/openzeppelin/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}"
    },
    "contracts/openzeppelin/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/bondingcurve/EthBondingCurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./BondingCurve.sol\";\n\n/// @title a bonding curve for purchasing FEI with ETH\n/// @author Fei Protocol\ncontract EthBondingCurve is BondingCurve {\n\n    struct BondingCurveParams {\n        uint256 scale;\n        uint256 buffer;\n        uint256 discount;\n        uint256 duration;\n        uint256 incentive;\n        address[] pcvDeposits;\n        uint256[] ratios;\n    }\n\n    constructor(\n        address core,\n        address oracle,\n        address backupOracle,\n        BondingCurveParams memory params\n    )\n        BondingCurve(\n            core,\n            oracle,\n            backupOracle,\n            params.scale,\n            params.pcvDeposits,\n            params.ratios,\n            params.duration,\n            params.incentive,\n            IERC20(address(0)),\n            params.discount,\n            params.buffer\n        )\n    {}\n\n    /// @notice purchase FEI for underlying tokens\n    /// @param to address to receive FEI\n    /// @param amountIn amount of underlying tokens input\n    /// @return amountOut amount of FEI received\n    function purchase(address to, uint256 amountIn)\n        external\n        payable\n        override\n        whenNotPaused\n        returns (uint256 amountOut)\n    {\n        require(\n            msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n        );\n        return _purchase(amountIn, to);\n    }\n\n    /// @notice get the balance of ETH held by the contract and ready to be allocated\n    function balance() public view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    function _allocateSingle(uint256 amount, address pcvDeposit)\n        internal\n        override\n    {\n        Address.sendValue(payable(pcvDeposit), amount);\n        IPCVDeposit(pcvDeposit).deposit();\n    }\n}\n"
    },
    "contracts/utils/LinearTokenTimelock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\n// Inspired by OpenZeppelin TokenTimelock contract\n// Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/TokenTimelock.sol\n\nimport \"./Timed.sol\";\nimport \"./ILinearTokenTimelock.sol\";\n\ncontract LinearTokenTimelock is ILinearTokenTimelock, Timed {\n\n    /// @notice ERC20 basic token contract being held in timelock\n    IERC20 public override lockedToken;\n\n    /// @notice beneficiary of tokens after they are released\n    address public override beneficiary;\n\n    /// @notice pending beneficiary appointed by current beneficiary\n    address public override pendingBeneficiary;\n\n    /// @notice initial balance of lockedToken\n    uint256 public override initialBalance;\n\n    uint256 internal lastBalance;\n\n    constructor(\n        address _beneficiary,\n        uint256 _duration,\n        address _lockedToken\n    ) Timed(_duration) {\n        require(_duration != 0, \"LinearTokenTimelock: duration is 0\");\n        require(\n            _beneficiary != address(0),\n            \"LinearTokenTimelock: Beneficiary must not be 0 address\"\n        );\n\n        beneficiary = _beneficiary;\n        _initTimed();\n\n        _setLockedToken(_lockedToken);\n    }\n\n    // Prevents incoming LP tokens from messing up calculations\n    modifier balanceCheck() {\n        if (totalToken() > lastBalance) {\n            uint256 delta = totalToken() - lastBalance;\n            initialBalance = initialBalance + delta;\n        }\n        _;\n        lastBalance = totalToken();\n    }\n\n    modifier onlyBeneficiary() {\n        require(\n            msg.sender == beneficiary,\n            \"LinearTokenTimelock: Caller is not a beneficiary\"\n        );\n        _;\n    }\n\n    /// @notice releases `amount` unlocked tokens to address `to`\n    function release(address to, uint256 amount) external override onlyBeneficiary balanceCheck {\n        require(amount != 0, \"LinearTokenTimelock: no amount desired\");\n\n        uint256 available = availableForRelease();\n        require(amount <= available, \"LinearTokenTimelock: not enough released tokens\");\n\n        _release(to, amount);\n    }\n\n    /// @notice releases maximum unlocked tokens to address `to`\n    function releaseMax(address to) external override onlyBeneficiary balanceCheck {\n        _release(to, availableForRelease());\n    }\n\n    /// @notice the total amount of tokens held by timelock\n    function totalToken() public view override virtual returns (uint256) {\n        return lockedToken.balanceOf(address(this));\n    }\n\n    /// @notice amount of tokens released to beneficiary\n    function alreadyReleasedAmount() public view override returns (uint256) {\n        return initialBalance - totalToken();\n    }\n\n    /// @notice amount of held tokens unlocked and available for release\n    function availableForRelease() public view override returns (uint256) {\n        uint256 elapsed = timeSinceStart();\n        uint256 _duration = duration;\n\n        uint256 totalAvailable = initialBalance * elapsed / _duration;\n        uint256 netAvailable = totalAvailable - alreadyReleasedAmount();\n        return netAvailable;\n    }\n\n    /// @notice current beneficiary can appoint new beneficiary, which must be accepted\n    function setPendingBeneficiary(address _pendingBeneficiary)\n        public\n        override\n        onlyBeneficiary\n    {\n        pendingBeneficiary = _pendingBeneficiary;\n        emit PendingBeneficiaryUpdate(_pendingBeneficiary);\n    }\n\n    /// @notice pending beneficiary accepts new beneficiary\n    function acceptBeneficiary() public override virtual {\n        _setBeneficiary(msg.sender);\n    }\n\n    function _setBeneficiary(address newBeneficiary) internal {\n        require(\n            newBeneficiary == pendingBeneficiary,\n            \"LinearTokenTimelock: Caller is not pending beneficiary\"\n        );\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdate(newBeneficiary);\n        pendingBeneficiary = address(0);\n    }\n\n    function _setLockedToken(address tokenAddress) internal {\n        lockedToken = IERC20(tokenAddress);\n    }\n\n    function _release(address to, uint256 amount) internal {\n        lockedToken.transfer(to, amount);\n        emit Release(beneficiary, to, amount);\n    }\n}\n"
    },
    "contracts/utils/ILinearTokenTimelock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../openzeppelin/token/ERC20/IERC20.sol\";\n\n/// @title LinearTokenTimelock interface\n/// @author Fei Protocol\ninterface ILinearTokenTimelock {\n    // ----------- Events -----------\n\n    event Release(address indexed _beneficiary, address indexed _recipient, uint256 _amount);\n    event BeneficiaryUpdate(address indexed _beneficiary);\n    event PendingBeneficiaryUpdate(address indexed _pendingBeneficiary);\n\n    // ----------- State changing api -----------\n\n    function release(address to, uint256 amount) external;\n\n    function releaseMax(address to) external;\n\n    function setPendingBeneficiary(address _pendingBeneficiary) external;\n\n    function acceptBeneficiary() external;\n\n\n    // ----------- Getters -----------\n\n    function lockedToken() external view returns (IERC20);\n\n    function beneficiary() external view returns (address);\n\n    function pendingBeneficiary() external view returns (address);\n\n    function initialBalance() external view returns (uint256);\n\n    function availableForRelease() external view returns (uint256);\n\n    function totalToken() external view returns(uint256);\n\n    function alreadyReleasedAmount() external view returns (uint256);\n}\n"
    },
    "contracts/openzeppelin/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/dao/Jelly.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"../openzeppelin/token/ERC20/ERC20.sol\";\nimport \"../openzeppelin/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"../openzeppelin/token/ERC20/extensions/ERC20Votes.sol\";\n\n\ncontract Jelly is ERC20, ERC20Permit, ERC20Votes {\n\n    /// @notice Address which may mint new tokens\n    address public minter;\n\n    /// @notice An event thats emitted when the minter address is changed\n    event MinterChanged(address minter, address newMinter);\n\n\n    /**\n     * @notice Construct a new Tribe token\n     * @param account The initial account to grant all the tokens\n     * @param minter_ The account with minting ability\n     */\n    constructor(\n        address account,\n        address minter_\n    )\n        ERC20(\"Jelly\", \"JELLY\")\n        ERC20Permit(\"Jelly\")\n    {\n        _mint(account, 1_000_000_000 * 10 ** decimals());\n        // _mint(account, 1_000_000_000e18);\n        minter = minter_;\n        emit MinterChanged(address(0), minter);\n    }\n\n    /**\n     * @notice Change the minter address\n     * @param minter_ The address of the new minter\n     */\n    function setMinter(address minter_) external {\n        require(msg.sender == minter, \"Tribe: only the minter can change the minter address\");\n        emit MinterChanged(minter, minter_);\n        minter = minter_;\n    }\n\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function _afterTokenTransfer(address from, address to, uint256 amount)\n        internal\n        override(ERC20, ERC20Votes)\n    {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    function _mint(address to, uint256 amount)\n        internal\n        override(ERC20, ERC20Votes)\n    {\n        super._mint(to, amount);\n    }\n\n    function _burn(address account, uint256 amount)\n        internal\n        override(ERC20, ERC20Votes)\n    {\n        super._burn(account, amount);\n    }\n}"
    },
    "contracts/openzeppelin/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "contracts/openzeppelin/token/ERC20/extensions/ERC20Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20Votes is ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        return _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}\n"
    },
    "contracts/openzeppelin/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/openzeppelin/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}"
    },
    "contracts/openzeppelin/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/openzeppelin/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/openzeppelin/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/openzeppelin/governance/compatibility/GovernorCompatibilityBravo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/Counters.sol\";\nimport \"../../utils/math/SafeCast.sol\";\nimport \"../extensions/IGovernorTimelock.sol\";\nimport \"../extensions/GovernorProposalThreshold.sol\";\nimport \"../Governor.sol\";\nimport \"./IGovernorCompatibilityBravo.sol\";\n\n/**\n * @dev Compatibility layer that implements GovernorBravo compatibility on to of {Governor}.\n *\n * This compatibility layer includes a voting system and requires a {IGovernorTimelock} compatible module to be added\n * through inheritance. It does not include token bindings, not does it include any variable upgrade patterns.\n *\n * NOTE: When using this module, you may need to enable the Solidity optimizer to avoid hitting the contract size limit.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorCompatibilityBravo is\n    IGovernorTimelock,\n    IGovernorCompatibilityBravo,\n    Governor,\n    GovernorProposalThreshold\n{\n    using Counters for Counters.Counter;\n    using Timers for Timers.BlockNumber;\n\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalDetails {\n        address proposer;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 abstainVotes;\n        mapping(address => Receipt) receipts;\n        bytes32 descriptionHash;\n    }\n\n    mapping(uint256 => ProposalDetails) private _proposalDetails;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=bravo\";\n    }\n\n    // ============================================== Proposal lifecycle ==============================================\n    /**\n     * @dev See {IGovernor-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override(IGovernor, Governor, GovernorProposalThreshold) returns (uint256) {\n        _storeProposal(_msgSender(), targets, values, new string[](calldatas.length), calldatas, description);\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        _storeProposal(_msgSender(), targets, values, signatures, calldatas, description);\n        return propose(targets, values, _encodeCalldata(signatures, calldatas), description);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-queue}.\n     */\n    function queue(uint256 proposalId) public virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        queue(\n            details.targets,\n            details.values,\n            _encodeCalldata(details.signatures, details.calldatas),\n            details.descriptionHash\n        );\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-execute}.\n     */\n    function execute(uint256 proposalId) public payable virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        execute(\n            details.targets,\n            details.values,\n            _encodeCalldata(details.signatures, details.calldatas),\n            details.descriptionHash\n        );\n    }\n\n    function cancel(uint256 proposalId) public virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n\n        require(\n            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),\n            \"GovernorBravo: proposer above threshold\"\n        );\n\n        _cancel(\n            details.targets,\n            details.values,\n            _encodeCalldata(details.signatures, details.calldatas),\n            details.descriptionHash\n        );\n    }\n\n    /**\n     * @dev Encodes calldatas with optional function signature.\n     */\n    function _encodeCalldata(string[] memory signatures, bytes[] memory calldatas)\n        private\n        pure\n        returns (bytes[] memory)\n    {\n        bytes[] memory fullcalldatas = new bytes[](calldatas.length);\n\n        for (uint256 i = 0; i < signatures.length; ++i) {\n            fullcalldatas[i] = bytes(signatures[i]).length == 0\n                ? calldatas[i]\n                : abi.encodeWithSignature(signatures[i], calldatas[i]);\n        }\n\n        return fullcalldatas;\n    }\n\n    /**\n     * @dev Store proposal metadata for later lookup\n     */\n    function _storeProposal(\n        address proposer,\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) private {\n        bytes32 descriptionHash = keccak256(bytes(description));\n        uint256 proposalId = hashProposal(targets, values, _encodeCalldata(signatures, calldatas), descriptionHash);\n\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        if (details.descriptionHash == bytes32(0)) {\n            details.proposer = proposer;\n            details.targets = targets;\n            details.values = values;\n            details.signatures = signatures;\n            details.calldatas = calldatas;\n            details.descriptionHash = descriptionHash;\n        }\n    }\n\n    // ==================================================== Views =====================================================\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold()\n        public\n        view\n        virtual\n        override(IGovernorCompatibilityBravo, GovernorProposalThreshold)\n        returns (uint256);\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-proposals}.\n     */\n    function proposals(uint256 proposalId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint256 id,\n            address proposer,\n            uint256 eta,\n            uint256 startBlock,\n            uint256 endBlock,\n            uint256 forVotes,\n            uint256 againstVotes,\n            uint256 abstainVotes,\n            bool canceled,\n            bool executed\n        )\n    {\n        id = proposalId;\n        eta = proposalEta(proposalId);\n        startBlock = proposalSnapshot(proposalId);\n        endBlock = proposalDeadline(proposalId);\n\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        proposer = details.proposer;\n        forVotes = details.forVotes;\n        againstVotes = details.againstVotes;\n        abstainVotes = details.abstainVotes;\n\n        ProposalState status = state(proposalId);\n        canceled = status == ProposalState.Canceled;\n        executed = status == ProposalState.Executed;\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-getActions}.\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        virtual\n        override\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return (details.targets, details.values, details.signatures, details.calldatas);\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-getReceipt}.\n     */\n    function getReceipt(uint256 proposalId, address voter) public view virtual override returns (Receipt memory) {\n        return _proposalDetails[proposalId].receipts[voter];\n    }\n\n    /**\n     * @dev See {IGovernorCompatibilityBravo-quorumVotes}.\n     */\n    function quorumVotes() public view virtual override returns (uint256) {\n        return quorum(block.number - 1);\n    }\n\n    // ==================================================== Voting ====================================================\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalDetails[proposalId].receipts[account].hasVoted;\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}. In this module, only forVotes count toward the quorum.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return quorum(proposalSnapshot(proposalId)) < details.forVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be scritly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        return details.forVotes > details.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows Governor Bravo.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight\n    ) internal virtual override {\n        ProposalDetails storage details = _proposalDetails[proposalId];\n        Receipt storage receipt = details.receipts[account];\n\n        require(!receipt.hasVoted, \"GovernorCompatibilityBravo: vote already cast\");\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = SafeCast.toUint96(weight);\n\n        if (support == uint8(VoteType.Against)) {\n            details.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            details.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            details.abstainVotes += weight;\n        } else {\n            revert(\"GovernorCompatibilityBravo: invalid vote type\");\n        }\n    }\n}\n"
    },
    "contracts/openzeppelin/governance/extensions/IGovernorTimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernor.sol\";\n\n/**\n * @dev Extension of the {IGovernor} for timelock supporting modules.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorTimelock is IGovernor {\n    event ProposalQueued(uint256 proposalId, uint256 eta);\n\n    function timelock() public view virtual returns (address);\n\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256);\n\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n}"
    },
    "contracts/openzeppelin/governance/extensions/GovernorProposalThreshold.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\n/**\n * @dev Extension of {Governor} for proposal restriction to token holders with a minimum balance.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorProposalThreshold is Governor {\n    /**\n     * @dev See {IGovernor-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        require(\n            getVotes(msg.sender, block.number - 1) >= proposalThreshold(),\n            \"GovernorCompatibilityBravo: proposer votes below proposal threshold\"\n        );\n\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public view virtual returns (uint256);\n}\n"
    },
    "contracts/openzeppelin/governance/Governor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/cryptography/ECDSA.sol\";\nimport \"../utils/cryptography/draft-EIP712.sol\";\nimport \"../utils/introspection/ERC165.sol\";\nimport \"../utils/math/SafeCast.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Timers.sol\";\nimport \"./IGovernor.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended though various modules.\n *\n * This contract is abstract and requires several function to be implemented in various modules:\n *\n * - A counting module must implement {quorum}, {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {getVotes}\n * - Additionanly, the {votingPeriod} must also be implemented\n *\n * _Available since v4.3._\n */\nabstract contract Governor is Context, ERC165, EIP712, IGovernor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    struct ProposalCore {\n        Timers.BlockNumber voteStart;\n        Timers.BlockNumber voteEnd;\n        bool executed;\n        bool canceled;\n    }\n\n    string private _name;\n\n    mapping(uint256 => ProposalCore) private _proposals;\n\n    /**\n     * @dev Restrict access to governor executing address. Some module might override the _executor function to make\n     * sure this modifier is consistant with the execution model.\n     */\n    modifier onlyGovernance() {\n        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    constructor(string memory name_) EIP712(name_, version()) {\n        _name = name_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == type(IGovernor).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-version}.\n     */\n    function version() public view virtual override returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the RLC encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * accross multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual override returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        ProposalCore memory proposal = _proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (proposal.voteStart.isPending()) {\n            return ProposalState.Pending;\n        } else if (proposal.voteEnd.isPending()) {\n            return ProposalState.Active;\n        } else if (proposal.voteEnd.isExpired()) {\n            return\n                _quorumReached(proposalId) && _voteSucceeded(proposalId)\n                    ? ProposalState.Succeeded\n                    : ProposalState.Defeated;\n        } else {\n            revert(\"Governor: unknown proposal id\");\n        }\n    }\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteStart.getDeadline();\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteEnd.getDeadline();\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Register a vote with a given support and voting weight.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight\n    ) internal virtual;\n\n    /**\n     * @dev See {IGovernor-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n        require(targets.length == values.length, \"Governor: invalid proposal length\");\n        require(targets.length == calldatas.length, \"Governor: invalid proposal length\");\n        require(targets.length > 0, \"Governor: empty proposal\");\n\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");\n\n        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();\n        uint64 deadline = snapshot + votingPeriod().toUint64();\n\n        proposal.voteStart.setDeadline(snapshot);\n        proposal.voteEnd.setDeadline(deadline);\n\n        emit ProposalCreated(\n            proposalId,\n            _msgSender(),\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            deadline,\n            description\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        ProposalState status = state(proposalId);\n        require(\n            status == ProposalState.Succeeded || status == ProposalState.Queued,\n            \"Governor: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overriden to implement different execution mechanism\n     */\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        string memory errorMessage = \"Governor: call reverted without message\";\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            Address.verifyCallResult(success, returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\n     * canceled to allow distinguishing it from executed proposals.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n        ProposalState status = state(proposalId);\n\n        require(\n            status != ProposalState.Canceled && status != ProposalState.Expired && status != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteBySig}.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\n            v,\n            r,\n            s\n        );\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");\n\n        uint256 weight = getVotes(account, proposal.voteStart.getDeadline());\n        _countVote(proposalId, account, support, weight);\n\n        emit VoteCast(account, proposalId, support, weight, reason);\n\n        return weight;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n}"
    },
    "contracts/openzeppelin/governance/compatibility/IGovernorCompatibilityBravo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernor.sol\";\n\n/**\n * @dev Interface extension that adds missing functions to the {Governor} core to provide `GovernorBravo` compatibility.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorCompatibilityBravo is IGovernor {\n    /**\n     * @dev Proposal structure from Compound Governor Bravo. Not actually used by the compatibility layer, as\n     * {{proposal}} returns a very different structure.\n     */\n    struct Proposal {\n        uint256 id;\n        address proposer;\n        uint256 eta;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 forVotes;\n        uint256 againstVotes;\n        uint256 abstainVotes;\n        bool canceled;\n        bool executed;\n        mapping(address => Receipt) receipts;\n    }\n\n    /**\n     * @dev Receipt structure from Compound Governor Bravo\n     */\n    struct Receipt {\n        bool hasVoted;\n        uint8 support;\n        uint96 votes;\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface.\n     */\n    function quorumVotes() public view virtual returns (uint256);\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The official record of all proposals ever proposed\"_.\n     */\n    function proposals(uint256)\n        public\n        view\n        virtual\n        returns (\n            uint256 id,\n            address proposer,\n            uint256 eta,\n            uint256 startBlock,\n            uint256 endBlock,\n            uint256 forVotes,\n            uint256 againstVotes,\n            uint256 abstainVotes,\n            bool canceled,\n            bool executed\n        );\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Function used to propose a new proposal\"_.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256);\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Queues a proposal of state succeeded\"_.\n     */\n    function queue(uint256 proposalId) public virtual;\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Executes a queued proposal if eta has passed\"_.\n     */\n    function execute(uint256 proposalId) public payable virtual;\n\n    /**\n     * @dev Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold.\n     */\n    function cancel(uint256 proposalId) public virtual;\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Gets actions of a proposal\"_.\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        );\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"Gets the receipt for a voter on a given proposal\"_.\n     */\n    function getReceipt(uint256 proposalId, address voter) public view virtual returns (Receipt memory);\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public view virtual returns (uint256);\n}"
    },
    "contracts/openzeppelin/governance/IGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernor is IERC165 {\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast.\n     *\n     * Note: `support` values should be seen as buckets. There interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() public view virtual returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = For, 1 = Against, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev block number used to retrieve user's votes and quorum.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev timestamp at which votes close.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev delay, in number of block, between the proposal is created and the vote starts. This can be increassed to\n     * leave time for users to buy voting power, of delegate it, before the voting of a proposal starts.\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev delay, in number of blocks, between the vote start and vote ends.\n     *\n     * Note: the {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * Note: The `blockNumber` parameter corresponds to the snaphot used for counting vote. This allows to scale the\n     * quroum depending on values such as the totalSupply of a token at this block (see {ERC20Votes}).\n     */\n    function quorum(uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `blockNumber`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns weither `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends\n     * {IGovernor-votingPeriod} blocks after the voting starts.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the user cryptographic signature.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n}\n"
    },
    "contracts/openzeppelin/utils/Timers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Tooling for timepoints, timers and delays\n */\nlibrary Timers {\n    struct Timestamp {\n        uint64 _deadline;\n    }\n\n    function getDeadline(Timestamp memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(Timestamp storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(Timestamp storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(Timestamp memory timer) internal view returns (bool) {\n        return timer._deadline > block.timestamp;\n    }\n\n    function isExpired(Timestamp memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.timestamp;\n    }\n\n    struct BlockNumber {\n        uint64 _deadline;\n    }\n\n    function getDeadline(BlockNumber memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(BlockNumber storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(BlockNumber memory timer) internal view returns (bool) {\n        return timer._deadline > block.number;\n    }\n\n    function isExpired(BlockNumber memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.number;\n    }\n}"
    },
    "contracts/openzeppelin/governance/extensions/GovernorTimelockControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IGovernorTimelock.sol\";\nimport \"../Governor.sol\";\nimport \"../TimelockController.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a\n * delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The\n * {Governor} needs the proposer (an ideally the executor) roles for the {Governor} to work properly.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorTimelockControl is IGovernorTimelock, Governor {\n    TimelockController private _timelock;\n    mapping(uint256 => bytes32) private _timelockIds;\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    constructor(TimelockController timelockAddress) {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, Governor) returns (bool) {\n        return interfaceId == type(IGovernorTimelock).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Overriden version of the {Governor-state} function with added support for the `Queued` status.\n     */\n    function state(uint256 proposalId) public view virtual override(IGovernor, Governor) returns (ProposalState) {\n        ProposalState status = super.state(proposalId);\n\n        if (status != ProposalState.Succeeded) {\n            return status;\n        }\n\n        // core tracks execution, so we just have to check if successful proposal have been queued.\n        bytes32 queueid = _timelockIds[proposalId];\n        if (queueid == bytes32(0)) {\n            return status;\n        } else if (_timelock.isOperationDone(queueid)) {\n            return ProposalState.Executed;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public accessor to check the eta of a queued proposal\n     */\n    function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {\n        uint256 eta = _timelock.getTimestamp(_timelockIds[proposalId]);\n        return eta == 1 ? 0 : eta; // _DONE_TIMESTAMP (1) should be replaced with a 0 value\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n        uint256 delay = _timelock.getMinDelay();\n        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);\n        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);\n\n        emit ProposalQueued(proposalId, block.timestamp + delay);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Overriden execute function that run the already queued proposal through the timelock.\n     */\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override {\n        _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, descriptionHash);\n    }\n\n    /**\n     * @dev Overriden version of the {Governor-_cancel} function to cancel the timelocked proposal if it as already\n     * been queued.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        if (_timelockIds[proposalId] != 0) {\n            _timelock.cancel(_timelockIds[proposalId]);\n            delete _timelockIds[proposalId];\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled and executed using the {Governor} workflow.\n     */\n    function updateTimelock(TimelockController newTimelock) external virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(TimelockController newTimelock) private {\n        emit TimelockChange(address(_timelock), address(newTimelock));\n        _timelock = newTimelock;\n    }\n}\n"
    },
    "contracts/openzeppelin/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) private {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n}\n"
    },
    "contracts/openzeppelin/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerable.sol\";\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {grantRole} to track enumerable memberships\n     */\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     */\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     */\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     */\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}"
    },
    "contracts/openzeppelin/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "contracts/openzeppelin/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}"
    },
    "contracts/core/Permissions.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../openzeppelin/access/AccessControlEnumerable.sol\";\nimport \"./IPermissions.sol\";\n\n/// @title Access control module for Core\n/// @author Fei Protocol\ncontract Permissions is IPermissions, AccessControlEnumerable {\n    bytes32 public constant override BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n    bytes32 public constant override MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant override PCV_CONTROLLER_ROLE = keccak256(\"PCV_CONTROLLER_ROLE\");\n    bytes32 public constant override GOVERN_ROLE = keccak256(\"GOVERN_ROLE\");\n    bytes32 public constant override GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n\n    constructor() {\n        // Appointed as a governor so guardian can have indirect access to revoke ability\n        _setupGovernor(address(this));\n\n        _setRoleAdmin(MINTER_ROLE, GOVERN_ROLE);\n        _setRoleAdmin(BURNER_ROLE, GOVERN_ROLE);\n        _setRoleAdmin(PCV_CONTROLLER_ROLE, GOVERN_ROLE);\n        _setRoleAdmin(GOVERN_ROLE, GOVERN_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GOVERN_ROLE);\n    }\n\n    modifier onlyGovernor() {\n        require(\n            isGovernor(msg.sender),\n            \"Permissions: Caller is not a governor\"\n        );\n        _;\n    }\n\n    modifier onlyGuardian() {\n        require(isGuardian(msg.sender), \"Permissions: Caller is not a guardian\");\n        _;\n    }\n\n    /// @notice creates a new role to be maintained\n    /// @param role the new role id\n    /// @param adminRole the admin role id for `role`\n    /// @dev can also be used to update admin of existing role\n    function createRole(bytes32 role, bytes32 adminRole)\n        external\n        override\n        onlyGovernor\n    {\n        _setRoleAdmin(role, adminRole);\n    }\n\n    /// @notice grants minter role to address\n    /// @param minter new minter\n    function grantMinter(address minter) external override onlyGovernor {\n        grantRole(MINTER_ROLE, minter);\n    }\n\n    /// @notice grants burner role to address\n    /// @param burner new burner\n    function grantBurner(address burner) external override onlyGovernor {\n        grantRole(BURNER_ROLE, burner);\n    }\n\n    /// @notice grants controller role to address\n    /// @param pcvController new controller\n    function grantPCVController(address pcvController)\n        external\n        override\n        onlyGovernor\n    {\n        grantRole(PCV_CONTROLLER_ROLE, pcvController);\n    }\n\n    /// @notice grants governor role to address\n    /// @param governor new governor\n    function grantGovernor(address governor) external override onlyGovernor {\n        grantRole(GOVERN_ROLE, governor);\n    }\n\n    /// @notice grants guardian role to address\n    /// @param guardian new guardian\n    function grantGuardian(address guardian) external override onlyGovernor {\n        grantRole(GUARDIAN_ROLE, guardian);\n    }\n\n    /// @notice revokes minter role from address\n    /// @param minter ex minter\n    function revokeMinter(address minter) external override onlyGovernor {\n        revokeRole(MINTER_ROLE, minter);\n    }\n\n    /// @notice revokes burner role from address\n    /// @param burner ex burner\n    function revokeBurner(address burner) external override onlyGovernor {\n        revokeRole(BURNER_ROLE, burner);\n    }\n\n    /// @notice revokes pcvController role from address\n    /// @param pcvController ex pcvController\n    function revokePCVController(address pcvController)\n        external\n        override\n        onlyGovernor\n    {\n        revokeRole(PCV_CONTROLLER_ROLE, pcvController);\n    }\n\n    /// @notice revokes governor role from address\n    /// @param governor ex governor\n    function revokeGovernor(address governor) external override onlyGovernor {\n        revokeRole(GOVERN_ROLE, governor);\n    }\n\n    /// @notice revokes guardian role from address\n    /// @param guardian ex guardian\n    function revokeGuardian(address guardian) external override onlyGovernor {\n        revokeRole(GUARDIAN_ROLE, guardian);\n    }\n\n    /// @notice revokes a role from address\n    /// @param role the role to revoke\n    /// @param account the address to revoke the role from\n    function revokeOverride(bytes32 role, address account)\n        external\n        override\n        onlyGuardian\n    {\n        require(role != GOVERN_ROLE, \"Permissions: Guardian cannot revoke governor\");\n\n        // External call because this contract is appointed as a governor and has access to revoke\n        this.revokeRole(role, account);\n    }\n\n\n    /// @notice checks if address is a minter\n    /// @param _address address to check\n    /// @return true _address is a minter\n    function isMinter(address _address) external view override returns (bool) {\n        return hasRole(MINTER_ROLE, _address);\n    }\n\n    /// @notice checks if address is a burner\n    /// @param _address address to check\n    /// @return true _address is a burner\n    function isBurner(address _address) external view override returns (bool) {\n        return hasRole(BURNER_ROLE, _address);\n    }\n\n    /// @notice checks if address is a controller\n    /// @param _address address to check\n    /// @return true _address is a controller\n    function isPCVController(address _address)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return hasRole(PCV_CONTROLLER_ROLE, _address);\n    }\n\n    /// @notice checks if address is a governor\n    /// @param _address address to check\n    /// @return true _address is a governor\n    // only virtual for testing mock override\n    function isGovernor(address _address)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return hasRole(GOVERN_ROLE, _address);\n    }\n\n    /// @notice checks if address is a guardian\n    /// @param _address address to check\n    /// @return true _address is a guardian\n    function isGuardian(address _address) public view override returns (bool) {\n        return hasRole(GUARDIAN_ROLE, _address);\n    }\n\n    function _setupGovernor(address governor) internal {\n        _setupRole(GOVERN_ROLE, governor);\n    }\n}\n"
    },
    "contracts/core/Core.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../openzeppelin/proxy/utils/Initializable.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./ICore.sol\";\nimport \"../token/Fei.sol\";\nimport \"../dao/Tribe.sol\";\n\n/// @title Source of truth for Fei Protocol\n/// @author Fei Protocol\n/// @notice maintains roles, access control, fei, tribe, genesisGroup, and the TRIBE treasury\ncontract Core is ICore, Permissions, Initializable {\n\n    /// @notice the address of the FEI contract\n    IFei public override fei;\n    \n    /// @notice the address of the TRIBE contract\n    IERC20 public override tribe;\n\n    // function init() external override initializer {\n    //     _setupGovernor(msg.sender);\n        \n    //     Fei _fei = new Fei(address(this));\n    //     _setFei(address(_fei));\n\n    //     Tribe _tribe = new Tribe(address(this), msg.sender);\n    //     _setTribe(address(_tribe));\n    // }\n\n    function init(address _fei, address _tribe) external override initializer {\n        _setupGovernor(msg.sender);\n        \n        // Fei _fei = new Fei(address(this));\n        _setFei(address(_fei));\n\n        // Tribe _tribe = new Tribe(address(this), msg.sender);\n        _setTribe(address(_tribe));\n    }\n\n    /// @notice sets Fei address to a new address\n    /// @param token new fei address\n    function setFei(address token) external override onlyGovernor {\n        _setFei(token);\n    }\n\n    /// @notice sets Tribe address to a new address\n    /// @param token new tribe address\n    function setTribe(address token) external override onlyGovernor {\n        _setTribe(token);\n    }\n\n    /// @notice sends TRIBE tokens from treasury to an address\n    /// @param to the address to send TRIBE to\n    /// @param amount the amount of TRIBE to send\n    function allocateTribe(address to, uint256 amount)\n        external\n        override\n        onlyGovernor\n    {\n        IERC20 _tribe = tribe;\n        require(\n            _tribe.balanceOf(address(this)) >= amount,\n            \"Core: Not enough Tribe\"\n        );\n\n        _tribe.transfer(to, amount);\n\n        emit TribeAllocation(to, amount);\n    }\n\n    function _setFei(address token) internal {\n        fei = IFei(token);\n        emit FeiUpdate(token);\n    }\n\n    function _setTribe(address token) internal {\n        tribe = IERC20(token);\n        emit TribeUpdate(token);\n    }\n}\n"
    },
    "contracts/openzeppelin/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/token/Fei.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../openzeppelin/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"./IIncentive.sol\";\nimport \"../refs/CoreRef.sol\";\n\n/// @title FEI stablecoin\n/// @author Fei Protocol\ncontract Fei is IFei, ERC20Burnable, CoreRef {\n    \n    /// @notice get associated incentive contract, 0 address if N/A\n    mapping(address => address) public override incentiveContract;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    /// @notice Fei token constructor\n    /// @param core Fei Core address to reference\n    constructor(address core) ERC20(\"Fei USD\", \"FEI\") CoreRef(core) {\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name())),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /// @param account the account to incentivize\n    /// @param incentive the associated incentive contract\n    function setIncentiveContract(address account, address incentive)\n        external\n        override\n        onlyGovernor\n    {\n        incentiveContract[account] = incentive;\n        emit IncentiveContractUpdate(account, incentive);\n    }\n\n    /// @notice mint FEI tokens\n    /// @param account the account to mint to\n    /// @param amount the amount to mint\n    function mint(address account, uint256 amount)\n        external\n        override\n        onlyMinter\n        whenNotPaused\n    {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    /// @notice burn FEI tokens from caller\n    /// @param amount the amount to burn\n    function burn(uint256 amount) public override(IFei, ERC20Burnable) {\n        super.burn(amount);\n        emit Burning(msg.sender, msg.sender, amount);\n    }\n\n    /// @notice burn FEI tokens from specified account\n    /// @param account the account to burn from\n    /// @param amount the amount to burn\n    function burnFrom(address account, uint256 amount)\n        public\n        override(IFei, ERC20Burnable)\n        onlyBurner\n        whenNotPaused\n    {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        super._transfer(sender, recipient, amount);\n        _checkAndApplyIncentives(sender, recipient, amount);\n    }\n\n    function _checkAndApplyIncentives(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        // incentive on sender\n        address senderIncentive = incentiveContract[sender];\n        if (senderIncentive != address(0)) {\n            IIncentive(senderIncentive).incentivize(\n                sender,\n                recipient,\n                msg.sender,\n                amount\n            );\n        }\n\n        // incentive on recipient\n        address recipientIncentive = incentiveContract[recipient];\n        if (recipientIncentive != address(0)) {\n            IIncentive(recipientIncentive).incentivize(\n                sender,\n                recipient,\n                msg.sender,\n                amount\n            );\n        }\n\n        // incentive on operator\n        address operatorIncentive = incentiveContract[msg.sender];\n        if (\n            msg.sender != sender &&\n            msg.sender != recipient &&\n            operatorIncentive != address(0)\n        ) {\n            IIncentive(operatorIncentive).incentivize(\n                sender,\n                recipient,\n                msg.sender,\n                amount\n            );\n        }\n\n        // all incentive, if active applies to every transfer\n        address allIncentive = incentiveContract[address(0)];\n        if (allIncentive != address(0)) {\n            IIncentive(allIncentive).incentivize(\n                sender,\n                recipient,\n                msg.sender,\n                amount\n            );\n        }\n    }\n\n    /// @notice permit spending of FEI\n    /// @param owner the FEI holder\n    /// @param spender the approved operator\n    /// @param value the amount approved\n    /// @param deadline the deadline after which the approval is no longer valid\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, \"Fei: EXPIRED\");\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR,\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"Fei: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/dao/Tribe.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\n// Forked from Uniswap's UNI\n// Reference: https://etherscan.io/address/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984#code\n\ncontract Tribe {\n    /// @notice EIP-20 token name for this token\n    // solhint-disable-next-line const-name-snakecase\n    string public constant name = \"Tribe\";\n\n    /// @notice EIP-20 token symbol for this token\n    // solhint-disable-next-line const-name-snakecase\n    string public constant symbol = \"TRIBE\";\n\n    /// @notice EIP-20 token decimals for this token\n    // solhint-disable-next-line const-name-snakecase\n    uint8 public constant decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    // solhint-disable-next-line const-name-snakecase\n    uint public totalSupply = 1_000_000_000e18; // 1 billion Tribe\n\n    /// @notice Address which may mint new tokens\n    address public minter;\n\n    /// @notice Allowance amounts on behalf of others\n    mapping (address => mapping (address => uint96)) internal allowances;\n\n    /// @notice Official record of token balances for each account\n    mapping (address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice The EIP-712 typehash for the permit struct used by the contract\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @notice An event thats emitted when the minter address is changed\n    event MinterChanged(address minter, address newMinter);\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Construct a new Tribe token\n     * @param account The initial account to grant all the tokens\n     * @param minter_ The account with minting ability\n     */\n    constructor(address account, address minter_) {\n        balances[account] = uint96(totalSupply);\n        emit Transfer(address(0), account, totalSupply);\n        minter = minter_;\n        emit MinterChanged(address(0), minter);\n    }\n\n    /**\n     * @notice Change the minter address\n     * @param minter_ The address of the new minter\n     */\n    function setMinter(address minter_) external {\n        require(msg.sender == minter, \"Tribe: only the minter can change the minter address\");\n        emit MinterChanged(minter, minter_);\n        minter = minter_;\n    }\n\n    /**\n     * @notice Mint new tokens\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to be minted\n     */\n    function mint(address dst, uint rawAmount) external {\n        require(msg.sender == minter, \"Tribe: only the minter can mint\");\n        require(dst != address(0), \"Tribe: cannot transfer to the zero address\");\n\n        // mint the amount\n        uint96 amount = safe96(rawAmount, \"Tribe: amount exceeds 96 bits\");\n        uint96 safeSupply = safe96(totalSupply, \"Tribe: totalSupply exceeds 96 bits\");\n        totalSupply = add96(safeSupply, amount, \"Tribe: totalSupply exceeds 96 bits\");\n\n        // transfer the amount to the recipient\n        balances[dst] = add96(balances[dst], amount, \"Tribe: transfer amount overflows\");\n        emit Transfer(address(0), dst, amount);\n\n        // move delegates\n        _moveDelegates(address(0), delegates[dst], amount);\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint rawAmount) external returns (bool) {\n        uint96 amount;\n        if (rawAmount == type(uint).max) {\n            amount = type(uint96).max;\n        } else {\n            amount = safe96(rawAmount, \"Tribe: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spends\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(address owner, address spender, uint rawAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        uint96 amount;\n        if (rawAmount == type(uint).max) {\n            amount = type(uint96).max;\n        } else {\n            amount = safe96(rawAmount, \"Tribe: amount exceeds 96 bits\");\n        }\n\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Tribe: invalid signature\");\n        require(signatory == owner, \"Tribe: unauthorized\");\n        require(block.timestamp <= deadline, \"Tribe: signature expired\");\n\n        allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint rawAmount) external returns (bool) {\n        uint96 amount = safe96(rawAmount, \"Tribe: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(rawAmount, \"Tribe: amount exceeds 96 bits\");\n\n        if (spender != src && spenderAllowance != type(uint96).max) {\n            uint96 newAllowance = sub96(spenderAllowance, amount, \"Tribe: transfer amount exceeds spender allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Tribe: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Tribe: invalid nonce\");\n        require(block.timestamp <= expiry, \"Tribe: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, \"Tribe: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transferTokens(address src, address dst, uint96 amount) internal {\n        require(src != address(0), \"Tribe: cannot transfer from the zero address\");\n        require(dst != address(0), \"Tribe: cannot transfer to the zero address\");\n\n        balances[src] = sub96(balances[src], amount, \"Tribe: transfer amount exceeds balance\");\n        balances[dst] = add96(balances[dst], amount, \"Tribe: transfer amount overflows\");\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Tribe: vote amount underflows\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Tribe: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n      uint32 blockNumber = safe32(block.number, \"Tribe: block number exceeds 32 bits\");\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n      } else {\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n      }\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal view returns (uint) {\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"
    },
    "contracts/openzeppelin/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/token/IIncentive.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\n/// @title incentive contract interface\n/// @author Fei Protocol\n/// @notice Called by FEI token contract when transferring with an incentivized address\n/// @dev should be appointed as a Minter or Burner as needed\ninterface IIncentive {\n    // ----------- Fei only state changing api -----------\n\n    /// @notice apply incentives on transfer\n    /// @param sender the sender address of the FEI\n    /// @param receiver the receiver address of the FEI\n    /// @param operator the operator (msg.sender) of the transfer\n    /// @param amount the amount of FEI transferred\n    function incentivize(\n        address sender,\n        address receiver,\n        address operator,\n        uint256 amount\n    ) external;\n}\n"
    },
    "contracts/pcv/utils/RatioPCVController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../../refs/CoreRef.sol\";\nimport \"../IPCVDeposit.sol\";\n\n/// @title a PCV controller for moving a ratio of the total value in the PCV deposit\n/// @author Fei Protocol\ncontract RatioPCVController is CoreRef {\n    \n    uint256 public constant BASIS_POINTS_GRANULARITY = 10_000;\n\n    /// @notice PCV controller constructor\n    /// @param _core Fei Core for reference\n    constructor(\n        address _core\n    ) CoreRef(_core) {}\n\n    /// @notice withdraw tokens from the input PCV deposit in basis points terms\n    /// @param pcvDeposit PCV deposit to withdraw from\n    /// @param to the address to send PCV to\n    /// @param basisPoints ratio of PCV to withdraw in basis points terms (1/10000)\n    function withdrawRatio(IPCVDeposit pcvDeposit, address to, uint256 basisPoints)\n        public\n        onlyPCVController\n        whenNotPaused\n    {\n        require(basisPoints <= BASIS_POINTS_GRANULARITY, \"RatioPCVController: basisPoints too high\");\n        uint256 amount = pcvDeposit.balance() * basisPoints / BASIS_POINTS_GRANULARITY;\n        require(amount != 0, \"RatioPCVController: no value to withdraw\");\n\n        pcvDeposit.withdraw(to, amount);\n    }\n\n    /// @notice withdraw a specific ERC20 token from the input PCV deposit in basis points terms\n    /// @param pcvDeposit PCV deposit to withdraw from\n    /// @param token the ERC20 token to withdraw\n    /// @param to the address to send tokens to\n    /// @param basisPoints ratio of PCV to withdraw in basis points terms (1/10000)\n    function withdrawRatioERC20(IPCVDeposit pcvDeposit, address token, address to, uint256 basisPoints)\n        public\n        onlyPCVController\n        whenNotPaused\n    {\n        require(basisPoints <= BASIS_POINTS_GRANULARITY, \"RatioPCVController: basisPoints too high\");\n        uint256 amount = IERC20(token).balanceOf(address(pcvDeposit)) * basisPoints / BASIS_POINTS_GRANULARITY;\n        require(amount != 0, \"RatioPCVController: no value to withdraw\");\n\n        pcvDeposit.withdrawERC20(token, to, amount);\n    }\n}\n"
    },
    "contracts/pcv/utils/IPCVDripController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../IPCVDeposit.sol\";\n\n/// @title a PCV dripping controller interface\n/// @author Fei Protocol\ninterface IPCVDripController {\n    // ----------- Events -----------\n\n    event SourceUpdate (address indexed oldSource, address indexed newSource);\n    event TargetUpdate (address indexed oldTarget, address indexed newTarget);\n    event DripAmountUpdate (uint256 oldDripAmount, uint256 newDripAmount);\n    event Dripped (address indexed source, address indexed target, uint256 amount);\n\n    // ----------- Governor only state changing api -----------\n\n    function setSource(IPCVDeposit newSource) external;\n\n    function setTarget(IPCVDeposit newTarget) external;\n\n    function setDripAmount(uint256 newDripAmount) external;\n\n    // ----------- Public state changing api -----------\n\n    function drip() external;\n\n    // ----------- Getters -----------\n\n    function source() external view returns (IPCVDeposit);\n\n    function target() external view returns (IPCVDeposit);\n\n    function dripAmount() external view returns (uint256);\n\n    function dripEligible() external view returns (bool);\n}\n\n"
    },
    "contracts/pcv/utils/PCVDripController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./IPCVDripController.sol\"; \nimport \"../../utils/Incentivized.sol\"; \nimport \"../../refs/CoreRef.sol\";\nimport \"../../utils/Timed.sol\";\n\n/// @title a PCV dripping controller\n/// @author Fei Protocol\ncontract PCVDripController is IPCVDripController, CoreRef, Timed, Incentivized {\n \n    /// @notice source PCV deposit to withdraw from\n    IPCVDeposit public override source;\n\n    /// @notice target address to drip to\n    IPCVDeposit public override target;\n\n    /// @notice amount to drip after each window\n    uint256 public override dripAmount;\n\n    /// @notice PCV Drip Controller constructor\n    /// @param _core Fei Core for reference\n    /// @param _source the PCV deposit to drip from\n    /// @param _target the PCV deposit to drip to\n    /// @param _frequency frequency of dripping\n    /// @param _dripAmount amount to drip on each drip\n    /// @param _incentiveAmount the FEI incentive for calling drip\n    constructor(\n        address _core,\n        IPCVDeposit _source,\n        IPCVDeposit _target,\n        uint256 _frequency,\n        uint256 _dripAmount,\n        uint256 _incentiveAmount\n    ) CoreRef(_core) Timed(_frequency) Incentivized(_incentiveAmount) {\n        target = _target;\n        emit TargetUpdate(address(0), address(_target));\n\n        source = _source;\n        emit SourceUpdate(address(0), address(_source));\n\n        dripAmount = _dripAmount;\n        emit DripAmountUpdate(0, _dripAmount);\n\n        // start timer\n        _initTimed();\n    }\n\n    /// @notice drip PCV to target by withdrawing from source\n    function drip()\n        external\n        override\n        afterTime\n        whenNotPaused\n    {\n        require(dripEligible(), \"PCVDripController: not eligible\");\n        \n        // reset timer\n        _initTimed();\n\n        // incentivize caller\n        _incentivize();\n        \n        // drip\n        source.withdraw(address(target), dripAmount);\n        target.deposit(); // trigger any deposit logic on the target\n        emit Dripped(address(source), address(target), dripAmount);\n    }\n\n    /// @notice set the new PCV Deposit source\n    function setSource(IPCVDeposit newSource)\n        external\n        override\n        onlyGovernor\n    {\n        require(address(newSource) != address(0), \"PCVDripController: zero address\");\n\n        address oldSource = address(source);\n        source = newSource;\n        emit SourceUpdate(oldSource, address(newSource));\n    }\n\n    /// @notice set the new PCV Deposit target\n    function setTarget(IPCVDeposit newTarget)\n        external\n        override\n        onlyGovernor\n    {\n        require(address(newTarget) != address(0), \"PCVDripController: zero address\");\n\n        address oldTarget = address(target);\n        target = newTarget;\n        emit TargetUpdate(oldTarget, address(newTarget));\n    }\n\n    /// @notice set the new drip amount\n    function setDripAmount(uint256 newDripAmount)\n        external\n        override\n        onlyGovernor\n    {\n        require(newDripAmount != 0, \"PCVDripController: zero drip amount\");\n\n        uint256 oldDripAmount = dripAmount;\n        dripAmount = newDripAmount;\n        emit DripAmountUpdate(oldDripAmount, newDripAmount);\n    }\n\n    /// @notice checks whether the target balance is less than the drip amount\n    function dripEligible() public view virtual override returns(bool) {\n        return target.balance() < dripAmount;\n    }\n}"
    },
    "contracts/pcv/uniswap/UniswapPCVController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../../openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../external/uniswap/libraries/Babylonian.sol\";\nimport \"./IUniswapPCVController.sol\";\nimport \"../../utils/Incentivized.sol\";\nimport \"../../refs/UniRef.sol\";\nimport \"../../external/UniswapV2Library.sol\";\nimport \"../../utils/Timed.sol\";\n\n/// @title a PCV controller for reweighting the Uniswap pair price to a peg\n/// @author Fei Protocol\ncontract UniswapPCVController is IUniswapPCVController, UniRef, Timed, Incentivized {\n    using Decimal for Decimal.D256;\n    using Babylonian for uint256;\n\n    uint256 internal constant BASIS_POINTS_GRANULARITY = 10_000;\n\n    /// @notice returns the linked pcv deposit contract\n    IPCVDeposit public override pcvDeposit;\n\n    Decimal.D256 internal _minDistanceForReweight;\n\n    /// @notice UniswapPCVController constructor\n    /// @param _core Fei Core for reference\n    /// @param _pcvDeposit PCV Deposit to reweight\n    /// @param _oracle oracle for reference\n    /// @param _backupOracle the backup oracle to reference\n    /// @param _incentiveAmount amount of FEI for triggering a reweight\n    /// @param _minDistanceForReweightBPs minimum distance from peg to reweight in basis points\n    /// @param _pair Uniswap pair contract to reweight\n    /// @param _reweightFrequency the frequency between reweights\n    constructor(\n        address _core,\n        address _pcvDeposit,\n        address _oracle,\n        address _backupOracle,\n        uint256 _incentiveAmount,\n        uint256 _minDistanceForReweightBPs,\n        address _pair,\n        uint256 _reweightFrequency\n    ) UniRef(_core, _pair, _oracle, _backupOracle) Timed(_reweightFrequency) Incentivized(_incentiveAmount) {\n        pcvDeposit = IPCVDeposit(_pcvDeposit);\n        emit PCVDepositUpdate(address(0), _pcvDeposit);\n\n        _minDistanceForReweight = Decimal.ratio(\n            _minDistanceForReweightBPs,\n            BASIS_POINTS_GRANULARITY\n        );\n        emit ReweightMinDistanceUpdate(0, _minDistanceForReweightBPs);\n\n        // start timer\n        _initTimed();\n    }\n\n    /// @notice reweights the linked PCV Deposit to the peg price. Needs to be reweight eligible\n    function reweight() external override whenNotPaused {\n        updateOracle();\n        require(\n            reweightEligible(),\n            \"UniswapPCVController: Not passed reweight time or not at min distance\"\n        );\n        _reweight();\n        _incentivize();\n\n        // reset timer\n        _initTimed();\n    }\n\n    /// @notice reweights regardless of eligibility\n    function forceReweight() external override onlyGuardianOrGovernor {\n        updateOracle();\n        _reweight();\n    }\n\n    /// @notice sets the target PCV Deposit address\n    function setPCVDeposit(address newPCVDeposit) external override onlyGovernor {\n        require(newPCVDeposit != address(0), \"UniswapPCVController: zero address\");\n\n        address oldPCVDeposit = address(pcvDeposit);\n        pcvDeposit = IPCVDeposit(newPCVDeposit);\n        emit PCVDepositUpdate(oldPCVDeposit, newPCVDeposit);\n    }\n\n    /// @notice sets the reweight min distance in basis points\n    function setReweightMinDistance(uint256 newReweightMinDistanceBPs)\n        external\n        override\n        onlyGovernor\n    {\n        require(newReweightMinDistanceBPs <= BASIS_POINTS_GRANULARITY, \"UniswapPCVController: reweight min distance too high\");\n        \n        uint256 oldReweightMinDistanceBPs = _minDistanceForReweight.mul(BASIS_POINTS_GRANULARITY).asUint256();\n        _minDistanceForReweight = Decimal.ratio(\n            newReweightMinDistanceBPs,\n            BASIS_POINTS_GRANULARITY\n        );\n        emit ReweightMinDistanceUpdate(oldReweightMinDistanceBPs, newReweightMinDistanceBPs);\n    }\n\n    /// @notice sets the reweight duration\n    function setDuration(uint256 _duration)\n        external\n        override\n        onlyGovernor\n    {\n       _setDuration(_duration);\n    }\n\n    /// @notice signal whether the reweight is available. Must have passed reweight frequency and minimum distance from peg\n    function reweightEligible() public view override returns (bool) {\n        bool meetsMagnitudeRequirement =\n            getDistanceToPeg().greaterThan(_minDistanceForReweight);\n        bool meetsTimeRequirement = isTimeEnded();\n        return meetsMagnitudeRequirement && meetsTimeRequirement;\n    }\n\n    /// @notice return current percent distance from peg\n    function getDistanceToPeg()\n        public\n        view\n        override\n        returns (Decimal.D256 memory distance)\n    {\n        Decimal.D256 memory price = _getUniswapPrice();\n        Decimal.D256 memory peg = readOracle();\n\n        // Get the absolute value raw distance from peg\n        Decimal.D256 memory delta;\n        if (price.lessThanOrEqualTo(peg)) {\n            delta = peg.sub(price);\n        } else {\n            delta = price.sub(peg);\n        }\n        // return percentage by dividing distance by peg\n        return delta.div(peg);\n    }\n\n    /// @notice minimum distance as a percentage from the peg for a reweight to be eligible\n    function minDistanceForReweight()\n        external\n        view\n        override\n        returns (Decimal.D256 memory)\n    {\n        return _minDistanceForReweight;\n    }\n\n    function _reweight() internal {\n        (uint256 feiReserves, uint256 tokenReserves) = getReserves();\n        if (feiReserves == 0 || tokenReserves == 0) {\n            return;\n        }\n\n        Decimal.D256 memory _peg = readOracle();\n\n        // Determine reweight algorithm based on side of peg\n        if (_isBelowPeg(_peg)) {\n            _rebase(_peg, feiReserves, tokenReserves);\n        } else {\n            _reverseReweight(_peg, feiReserves, tokenReserves);\n        }\n\n        emit Reweight(msg.sender);\n    }\n\n    // Rebases the pool back up to the peg by directly burning FEI\n    function _rebase(\n        Decimal.D256 memory _peg,\n        uint256 feiReserves, \n        uint256 tokenReserves\n    ) internal {\n        // Calculate the ideal amount of FEI in the pool for the reserves of the non-FEI token\n        uint256 targetAmount = _peg.mul(tokenReserves).asUint256();\n\n        // burn the excess FEI not needed from the pool\n        uint256 burnAmount = feiReserves - targetAmount;\n        fei().burnFrom(address(pair), burnAmount);\n\n        // sync the pair to restore the reserves \n        pair.sync();\n    }\n\n    // Restores peg from above by minting and selling FEI\n    function _reverseReweight(        \n        Decimal.D256 memory _peg,\n        uint256 feiReserves, \n        uint256 tokenReserves\n    ) internal {\n        // calculate amount FEI needed to return to peg then swap\n        uint256 amountIn = _getAmountToPegFei(feiReserves, tokenReserves, _peg);\n\n        // mint FEI directly to the pair before swapping\n        IFei _fei = fei();\n        _fei.mint(address(pair), amountIn);\n\n        _swap(address(_fei), amountIn, feiReserves, tokenReserves);\n\n        // Redeposit purchased tokens\n        _deposit();\n    }\n\n    function _swap(\n        address tokenIn,\n        uint256 amount,\n        uint256 reservesIn,\n        uint256 reservesOut\n    ) internal returns (uint256 amountOut) {\n\n        amountOut = UniswapV2Library.getAmountOut(amount, reservesIn, reservesOut);\n\n        (uint256 amount0Out, uint256 amount1Out) =\n            pair.token0() == tokenIn\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n        pair.swap(amount0Out, amount1Out, address(this), new bytes(0));\n    }\n\n    function _deposit() internal {\n        // resupply all held PCV\n        IERC20 erc20 = IERC20(token);\n        uint256 balance = erc20.balanceOf(address(this));\n\n        // transfer to PCV deposit and trigger deposit logic\n        SafeERC20.safeTransfer(erc20, address(pcvDeposit), balance);\n        pcvDeposit.deposit();\n    }\n\n    /**\n    * @notice utility for calculating absolute distance from peg based on reserves\n    * @param reserveTarget pair reserves of the asset desired to trade with\n    * @param reserveOther pair reserves of the non-traded asset\n    * @param peg the target peg reported as Target per Other\n    * \n    * Derivation:\n    * Recall Uniswap's price and invariant formula, P = x/y and k = x*y\n    * The objective is to return some delta |d| such that \n    *    x' = x + d\n    *    y' = k / x'\n    *    x'/y' = P' for target peg P'\n    * \n    * Plugging in x' and y' to the new price formula gives:\n    *    P' = (x + d)^2 / k\n    *    sqrt(P' * k) = x + d\n    *    sqrt(P' * x * y) - x = d\n    * The resulting function returns |d| adjusted for uniswap fees\n    */\n    function _getAmountToPeg(\n        uint256 reserveTarget,\n        uint256 reserveOther,\n        Decimal.D256 memory peg\n    ) internal pure returns (uint256) {\n        uint256 radicand = peg.mul(reserveTarget).mul(reserveOther).asUint256();\n        uint256 root = radicand.sqrt();\n        if (root > reserveTarget) {\n            return (root - reserveTarget) * 1000 / 997; // divide to include the .3% uniswap fee\n        }\n        return (reserveTarget - root) * 1000 / 997; // divide to include the .3% uniswap fee\n    }\n\n    /// @notice calculate amount of Fei needed to trade back to the peg\n    function _getAmountToPegFei(\n        uint256 feiReserves,\n        uint256 tokenReserves,\n        Decimal.D256 memory peg\n    ) internal pure returns (uint256) {\n        return _getAmountToPeg(feiReserves, tokenReserves, peg);\n    }\n\n    /// @notice get uniswap price\n    /// @return price reported as Fei per X\n    function _getUniswapPrice() internal view returns (Decimal.D256 memory) {\n        (uint256 reserveFei, uint256 reserveOther) = getReserves();\n        return Decimal.ratio(reserveFei, reserveOther);\n    }\n\n    /// @notice returns true if price is below the peg\n    /// @dev counterintuitively checks if peg < price because price is reported as FEI per X\n    function _isBelowPeg(Decimal.D256 memory peg) internal view returns (bool) {\n        return peg.lessThan(_getUniswapPrice());\n    }\n}\n"
    },
    "contracts/external/uniswap/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}"
    },
    "contracts/pcv/uniswap/IUniswapPCVController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../IPCVDeposit.sol\";\nimport \"../../external/Decimal.sol\";\n\n/// @title a Uniswap PCV Controller interface\n/// @author Fei Protocol\ninterface IUniswapPCVController {\n    // ----------- Events -----------\n\n    event Reweight(address indexed _caller);\n\n    event PCVDepositUpdate(\n        address indexed _oldPCVDeposit,\n        address indexed _newPCVDeposit\n    );\n\n    event ReweightMinDistanceUpdate(\n        uint256 _oldMinDistanceBasisPoints,\n        uint256 _newMinDistanceBasisPoints\n    );\n\n    // ----------- State changing API -----------\n\n    function reweight() external;\n\n    // ----------- Governor only state changing API -----------\n\n    function forceReweight() external;\n\n    function setPCVDeposit(address _pcvDeposit) external;\n\n    function setDuration(uint256 _duration) external;\n\n    function setReweightMinDistance(uint256 basisPoints) external;\n\n    // ----------- Getters -----------\n\n    function pcvDeposit() external view returns (IPCVDeposit);\n\n    function reweightEligible() external view returns (bool);\n\n    function getDistanceToPeg() external view returns (Decimal.D256 memory);\n\n    function minDistanceForReweight()\n        external\n        view\n        returns (Decimal.D256 memory);\n}\n"
    },
    "contracts/refs/UniRef.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./OracleRef.sol\";\nimport \"./IUniRef.sol\";\n\n/// @title A Reference to Uniswap\n/// @author Fei Protocol\n/// @notice defines some utilities around interacting with Uniswap\n/// @dev the uniswap pair should be FEI and another asset\nabstract contract UniRef is IUniRef, OracleRef {\n\n    /// @notice the referenced Uniswap pair contract\n    IUniswapV2Pair public override pair;\n\n    /// @notice the address of the non-fei underlying token\n    address public override token;\n\n    /// @notice UniRef constructor\n    /// @param _core Fei Core to reference\n    /// @param _pair Uniswap pair to reference\n    /// @param _oracle oracle to reference\n    /// @param _backupOracle backup oracle to reference\n    constructor(\n        address _core,\n        address _pair,\n        address _oracle,\n        address _backupOracle\n    ) OracleRef(_core, _oracle, _backupOracle, 0, false) {\n        _setupPair(_pair);\n        _setDecimalsNormalizerFromToken(_token());\n    }\n\n    /// @notice set the new pair contract\n    /// @param newPair the new pair\n    function setPair(address newPair) external override virtual onlyGovernor {\n        _setupPair(newPair);\n    }\n\n    /// @notice pair reserves with fei listed first\n    function getReserves()\n        public\n        view\n        override\n        returns (uint256 feiReserves, uint256 tokenReserves)\n    {\n        address token0 = pair.token0();\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        (feiReserves, tokenReserves) = address(fei()) == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n        return (feiReserves, tokenReserves);\n    }\n\n    function _setupPair(address newPair) internal {\n        require(newPair != address(0), \"UniRef: zero address\");\n\n        address oldPair = address(pair);\n        pair = IUniswapV2Pair(newPair);\n        emit PairUpdate(oldPair, newPair);\n\n        token = _token();\n    }\n\n    function _token() internal view returns (address) {\n        address token0 = pair.token0();\n        if (address(fei()) == token0) {\n            return pair.token1();\n        }\n        return token0;\n    }\n}\n"
    },
    "contracts/external/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nimport \"../openzeppelin/utils/math/SafeMath.sol\";\n\n library UniswapV2Library {\n    using SafeMath for uint;\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n }"
    },
    "contracts/refs/IUniRef.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../external/uniswap/core/interfaces/IUniswapV2Pair.sol\";\n\n/// @title UniRef interface\n/// @author Fei Protocol\ninterface IUniRef {\n    // ----------- Events -----------\n\n    event PairUpdate(address indexed oldPair, address indexed newPair);\n\n    // ----------- Governor only state changing api -----------\n\n    function setPair(address newPair) external;\n\n    // ----------- Getters -----------\n\n    function pair() external view returns (IUniswapV2Pair);\n\n    function token() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (uint256 feiReserves, uint256 tokenReserves);\n\n}\n"
    },
    "contracts/external/uniswap/core/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/pcv/uniswap/PCVSwapperUniswap.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./IPCVSwapper.sol\";\nimport \"../utils/WethPCVDeposit.sol\";\nimport \"../../utils/Incentivized.sol\";\nimport \"../../refs/OracleRef.sol\";\nimport \"../../utils/Timed.sol\";\nimport \"../../external/UniswapV2Library.sol\";\nimport \"../../openzeppelin/utils/math/Math.sol\";\nimport \"../../openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../external/uniswap/core/interfaces/IUniswapV2Pair.sol\";\n\n/// @title implementation for PCV Swapper that swaps ERC20 tokens on Uniswap\n/// @author eswak\ncontract PCVSwapperUniswap is IPCVSwapper, WethPCVDeposit, OracleRef, Timed, Incentivized {\n    using SafeERC20 for IERC20;\n    using Decimal for Decimal.D256;\n\n    // ----------- Events -----------\t\n    event UpdateMaximumSlippage(uint256 oldMaxSlippage, uint256 newMaximumSlippage);\t\n    event UpdateMaxSpentPerSwap(uint256 oldMaxSpentPerSwap, uint256 newMaxSpentPerSwap);\t\n\n    /// @notice the token to spend on swap (outbound)\n    address public immutable override tokenSpent;\n    /// @notice the token to receive on swap (inbound)\n    address public immutable override tokenReceived;\n    /// @notice the address that will receive the inbound tokens\n    address public override tokenReceivingAddress;\n    /// @notice the maximum amount of tokens to spend on every swap\n    uint256 public maxSpentPerSwap;\n    /// @notice the maximum amount of slippage vs oracle price\n    uint256 public maximumSlippageBasisPoints;\n    uint256 public constant BASIS_POINTS_GRANULARITY = 10_000;\n\n    /// @notice Uniswap pair to swap on\n    IUniswapV2Pair public immutable pair;\n\n    struct OracleData {\n        address _oracle;\n        address _backupOracle;\n        // invert should be false if the oracle is reported in tokenSpent terms otherwise true\n        bool _invertOraclePrice;\n        // The decimalsNormalizer should be calculated as tokenSpent.decimals() - tokenReceived.decimals() if invert is false, otherwise reverse order\n        int256 _decimalsNormalizer;\n    }\n\n    constructor(\n        address _core,\n        IUniswapV2Pair _pair,\n        // solhint-disable-next-line var-name-mixedcase\n        OracleData memory oracleData,\n        uint256 _swapFrequency,\n        address _tokenSpent,\n        address _tokenReceived,\n        address _tokenReceivingAddress,\n        uint256 _maxSpentPerSwap,\n        uint256 _maximumSlippageBasisPoints,\n        uint256 _swapIncentiveAmount\n    ) OracleRef(\n      _core, \n      oracleData._oracle, \n      oracleData._backupOracle,\n      oracleData._decimalsNormalizer,\n      oracleData._invertOraclePrice\n    ) Timed(_swapFrequency) Incentivized(_swapIncentiveAmount) {\n        require(_pair.token0() == _tokenSpent || _pair.token1() == _tokenSpent, \"PCVSwapperUniswap: token spent not in pair\");\n        require(_pair.token0() == _tokenReceived || _pair.token1() == _tokenReceived, \"PCVSwapperUniswap: token received not in pair\");\n        pair = _pair;\n        tokenSpent = _tokenSpent;\n        tokenReceived = _tokenReceived;\n\n        tokenReceivingAddress = _tokenReceivingAddress;\n        emit UpdateReceivingAddress(address(0), _tokenReceivingAddress);\n\n        maxSpentPerSwap = _maxSpentPerSwap;\n        emit UpdateMaxSpentPerSwap(0, _maxSpentPerSwap);\n\n        maximumSlippageBasisPoints = _maximumSlippageBasisPoints;\n        emit UpdateMaximumSlippage(0, _maximumSlippageBasisPoints);\n\n        // start timer\n        _initTimed();\n    }\n\n    // =======================================================================\n    // IPCVDeposit interface override\n    // =======================================================================\n\n    /// @notice withdraw tokenReceived from the contract\n    /// @param to address destination of the ERC20\n    /// @param amount quantity of tokenReceived to send\n    function withdraw(address to, uint256 amount) external override onlyPCVController {\n        withdrawERC20(tokenReceived, to, amount);\n    }\n\n    /// @notice Reads the balance of tokenReceived held in the contract\n\t\t/// @return held balance of token of tokenReceived\n    function balance() external view override returns(uint256) {\n      return IERC20(tokenReceived).balanceOf(address(this));\n    }\n\n    // =======================================================================\n    // IPCVSwapper interface override\n    // =======================================================================\n\n    /// @notice Sets the address receiving swap's inbound tokens\n    /// @param newTokenReceivingAddress the address that will receive tokens\n    function setReceivingAddress(address newTokenReceivingAddress) external override onlyGovernor {\n      require(newTokenReceivingAddress != address(0), \"PCVSwapperUniswap: zero address\");\n      address oldTokenReceivingAddress = tokenReceivingAddress;\n      tokenReceivingAddress = newTokenReceivingAddress;\n      emit UpdateReceivingAddress(oldTokenReceivingAddress, newTokenReceivingAddress);\n    }\n\n    // =======================================================================\n    // Setters\n    // =======================================================================\n\n    /// @notice Sets the maximum slippage vs Oracle price accepted during swaps\n    /// @param newMaximumSlippageBasisPoints the maximum slippage expressed in basis points (1/10_000)\n    function setMaximumSlippage(uint256 newMaximumSlippageBasisPoints) external onlyGovernor {\n        uint256 oldMaxSlippage = maximumSlippageBasisPoints;\n        require(newMaximumSlippageBasisPoints <= BASIS_POINTS_GRANULARITY, \"PCVSwapperUniswap: Exceeds bp granularity.\");\n        maximumSlippageBasisPoints = newMaximumSlippageBasisPoints;\n        emit UpdateMaximumSlippage(oldMaxSlippage, newMaximumSlippageBasisPoints);\n    }\n\n    /// @notice Sets the maximum tokens spent on each swap\n    /// @param newMaxSpentPerSwap the maximum number of tokens to be swapped on each call\n    function setMaxSpentPerSwap(uint256 newMaxSpentPerSwap) external onlyGovernor {\n        uint256 oldMaxSpentPerSwap = maxSpentPerSwap;\n        require(newMaxSpentPerSwap != 0, \"PCVSwapperUniswap: Cannot swap 0.\");\n        maxSpentPerSwap = newMaxSpentPerSwap;\n        emit UpdateMaxSpentPerSwap(oldMaxSpentPerSwap, newMaxSpentPerSwap);\t\n    }\n\n    /// @notice sets the minimum time between swaps\n\t\t/// @param _duration minimum time between swaps in seconds\n    function setSwapFrequency(uint256 _duration) external onlyGovernor {\n       _setDuration(_duration);\n    }\n\n    // =======================================================================\n    // External functions\n    // =======================================================================\n\n    /// @notice Swap tokenSpent for tokenReceived\n    function swap() external override afterTime whenNotPaused {\n\t    // Reset timer\t\n      _initTimed();\t\n      \n      updateOracle();\n\n      uint256 amountIn = _getExpectedAmountIn();\n      uint256 amountOut = _getExpectedAmountOut(amountIn);\n      uint256 minimumAcceptableAmountOut = _getMinimumAcceptableAmountOut(amountIn);\n\n      // Check spot price vs oracle price discounted by max slippage\n      // E.g. for a max slippage of 3%, spot price must be >= 97% oraclePrice\n      require(minimumAcceptableAmountOut <= amountOut, \"PCVSwapperUniswap: slippage too high.\");\n\n      // Perform swap\n      IERC20(tokenSpent).safeTransfer(address(pair), amountIn);\n      (uint256 amount0Out, uint256 amount1Out) =\n          pair.token0() == address(tokenSpent)\n              ? (uint256(0), amountOut)\n              : (amountOut, uint256(0));\n      pair.swap(amount0Out, amount1Out, tokenReceivingAddress, new bytes(0));\n\n      // Emit event\n      emit Swap(\n        msg.sender,\n        tokenSpent,\n        tokenReceived,\n        amountIn,\n        amountOut\n      );\n\n      // Incentivize call with FEI rewards\n      _incentivize();\n    }\n\n    // =======================================================================\n    // Internal functions\n    // =======================================================================\n\n    function _getExpectedAmountIn() internal view returns (uint256) {\n      uint256 amount = IERC20(tokenSpent).balanceOf(address(this));\n      require(amount != 0, \"PCVSwapperUniswap: no tokenSpent left.\");\n      return Math.min(maxSpentPerSwap, amount);\n    }\n\n    function _getExpectedAmountOut(uint256 amountIn) internal view returns (uint256) {\n      // Get pair reserves\n      (uint256 _token0, uint256 _token1, ) = pair.getReserves();\n      (uint256 tokenSpentReserves, uint256 tokenReceivedReserves) =\n          pair.token0() == tokenSpent\n              ? (_token0, _token1)\n              : (_token1, _token0);\n\n      // Prepare swap\n      uint256 amountOut = UniswapV2Library.getAmountOut(\n        amountIn,\n        tokenSpentReserves,\n        tokenReceivedReserves\n      );\n\n      return amountOut;\n    }\n\n    function _getMinimumAcceptableAmountOut(uint256 amountIn) internal view returns (uint256) {\n      Decimal.D256 memory oraclePrice = readOracle();\n      Decimal.D256 memory oracleAmountOut = oraclePrice.mul(amountIn);\n      Decimal.D256 memory maxSlippage = Decimal.ratio(BASIS_POINTS_GRANULARITY - maximumSlippageBasisPoints, BASIS_POINTS_GRANULARITY);\n      Decimal.D256 memory oraclePriceMinusSlippage = maxSlippage.mul(oracleAmountOut);\n      return oraclePriceMinusSlippage.asUint256();\n    }\n}\n"
    },
    "contracts/pcv/uniswap/IPCVSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\n/// @title a PCV Swapper interface\n/// @author eswak\ninterface IPCVSwapper {\n\n    // ----------- Events -----------\n    event UpdateReceivingAddress(address oldTokenReceivingAddress, address newTokenReceivingAddress);\n\n    event Swap(\n        address indexed _caller,\n        address indexed _tokenSpent,\n        address indexed _tokenReceived,\n        uint256 _amountSpent,\n        uint256 _amountReceived\n    );\n\n    // ----------- State changing api -----------\n\n    function swap() external;\n\n    // ----------- Governor only state changing api -----------\n\n    function setReceivingAddress(address _tokenReceivingAddress) external;\n\n    // ----------- Getters -----------\n\n    function tokenSpent() external view returns (address);\n    function tokenReceived() external view returns (address);\n    function tokenReceivingAddress() external view returns (address);\n\n}\n"
    },
    "contracts/pcv/utils/WethPCVDeposit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../../external/uniswap/periphery/interfaces/IWETH.sol\";\nimport \"../PCVDeposit.sol\";\nimport \"../../openzeppelin/utils/Address.sol\";\n\n/// @title base class for a WethPCVDeposit PCV Deposit\n/// @author Fei Protocol\nabstract contract WethPCVDeposit is PCVDeposit {\n    /// @notice WETH9 address\n    IWETH public constant WETH =\n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /// @notice Empty callback on ETH reception\n    receive() external payable virtual {}\n\n    /// @notice Wraps all ETH held by the contract to WETH\n    /// Anyone can call it\n    function wrapETH() public {\n        uint256 ethBalance = address(this).balance;\n        if (ethBalance != 0) {\n            IWETH(WETH).deposit{value: ethBalance}();\n        }\n    }\n\n    /// @notice deposit\n    function deposit() external virtual override {\n        wrapETH();\n    }\n\n    /// @notice withdraw ETH from the contract\n    /// @param to address to send ETH\n    /// @param amountOut amount of ETH to send\n    function withdrawETH(address payable to, uint256 amountOut)\n        external\n        override\n        onlyPCVController\n    {\n        IWETH(WETH).withdraw(amountOut);\n        Address.sendValue(to, amountOut);\n        emit WithdrawETH(msg.sender, to, amountOut);\n    }\n}\n"
    },
    "contracts/external/uniswap/periphery/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n"
    },
    "contracts/pcv/PCVDeposit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../refs/CoreRef.sol\";\nimport \"./IPCVDeposit.sol\";\nimport \"../openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\n\n/// @title abstract contract for withdrawing ERC-20 tokens using a PCV Controller\n/// @author Fei Protocol\nabstract contract PCVDeposit is IPCVDeposit, CoreRef {\n    using SafeERC20 for IERC20;\n\n    /// @notice withdraw ERC20 from the contract\n    /// @param token address of the ERC20 to send\n    /// @param to address destination of the ERC20\n    /// @param amount quantity of ERC20 to send\n    function withdrawERC20(\n      address token, \n      address to, \n      uint256 amount\n    ) public override onlyPCVController {\n        _withdrawERC20(token, to, amount);\n    }\n\n    function _withdrawERC20(\n      address token, \n      address to, \n      uint256 amount\n    ) internal {\n        IERC20(token).safeTransfer(to, amount);\n        emit WithdrawERC20(msg.sender, token, to, amount);\n    }\n\n    /// @notice withdraw ETH from the contract\n    /// @param to address to send ETH\n    /// @param amountOut amount of ETH to send\n    function withdrawETH(address payable to, uint256 amountOut) external virtual override onlyPCVController {\n        Address.sendValue(to, amountOut);\n        emit WithdrawETH(msg.sender, to, amountOut);\n    }\n}\n"
    },
    "contracts/pcv/uniswap/UniswapPCVDeposit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./IUniswapPCVDeposit.sol\";\nimport \"../PCVDeposit.sol\";\nimport \"../../refs/UniRef.sol\";\nimport \"../../external/uniswap/periphery/interfaces/IWETH.sol\";\nimport \"../../openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title implementation for Uniswap LP PCV Deposit\n/// @author Fei Protocol\ncontract UniswapPCVDeposit is IUniswapPCVDeposit, PCVDeposit, UniRef {\n    using Decimal for Decimal.D256;\n\n    /// @notice a slippage protection parameter, deposits revert when spot price is > this % from oracle\n    uint256 public override maxBasisPointsFromPegLP;\n\n    uint256 public constant BASIS_POINTS_GRANULARITY = 10_000;\n\n    /// @notice the Uniswap router contract\n    IUniswapV2Router02 public override router;\n\n    /// @notice Uniswap PCV Deposit constructor\n    /// @param _core Fei Core for reference\n    /// @param _pair Uniswap Pair to deposit to\n    /// @param _router Uniswap Router\n    /// @param _oracle oracle for reference\n    /// @param _backupOracle the backup oracle to reference\n    /// @param _maxBasisPointsFromPegLP the max basis points of slippage from peg allowed on LP deposit\n    constructor(\n        address _core,\n        address _pair,\n        address _router,\n        address _oracle,\n        address _backupOracle,\n        uint256 _maxBasisPointsFromPegLP\n    ) UniRef(_core, _pair, _oracle, _backupOracle) {\n        router = IUniswapV2Router02(_router);\n\n        _approveToken(address(fei()));\n        _approveToken(token);\n        _approveToken(_pair);\n\n        maxBasisPointsFromPegLP = _maxBasisPointsFromPegLP;\n        emit MaxBasisPointsFromPegLPUpdate(0, _maxBasisPointsFromPegLP);\n    }\n\n    receive() external payable {\n        _wrap();\n    }\n\n    /// @notice deposit tokens into the PCV allocation\n    function deposit() external override whenNotPaused {\n        updateOracle();\n\n        // Calculate amounts to provide liquidity\n        uint256 tokenAmount = IERC20(token).balanceOf(address(this));\n        uint256 feiAmount = readOracle().mul(tokenAmount).asUint256();\n\n        _addLiquidity(tokenAmount, feiAmount);\n\n        _burnFeiHeld(); // burn any FEI dust from LP\n\n        emit Deposit(msg.sender, tokenAmount);\n    }\n\n    /// @notice withdraw tokens from the PCV allocation\n    /// @param amountUnderlying of tokens withdrawn\n    /// @param to the address to send PCV to\n    /// @dev has rounding errors on amount to withdraw, can differ from the input \"amountUnderlying\"\n    function withdraw(address to, uint256 amountUnderlying)\n        external\n        override\n        onlyPCVController\n        whenNotPaused\n    {\n        uint256 totalUnderlying = balance();\n        require(\n            amountUnderlying <= totalUnderlying,\n            \"UniswapPCVDeposit: Insufficient underlying\"\n        );\n\n        uint256 totalLiquidity = liquidityOwned();\n\n        // ratio of LP tokens needed to get out the desired amount\n        Decimal.D256 memory ratioToWithdraw =\n            Decimal.ratio(amountUnderlying, totalUnderlying);\n\n        // amount of LP tokens to withdraw factoring in ratio\n        uint256 liquidityToWithdraw =\n            ratioToWithdraw.mul(totalLiquidity).asUint256();\n\n        // Withdraw liquidity from the pair and send to target\n        uint256 amountWithdrawn = _removeLiquidity(liquidityToWithdraw);\n        SafeERC20.safeTransfer(IERC20(token), to, amountWithdrawn);\n\n        _burnFeiHeld(); // burn remaining FEI\n\n        emit Withdrawal(msg.sender, to, amountWithdrawn);\n    }\n\n    /// @notice sets the new slippage parameter for depositing liquidity\n    /// @param _maxBasisPointsFromPegLP the new distance in basis points (1/10000) from peg beyond which a liquidity provision will fail\n    function setMaxBasisPointsFromPegLP(uint256 _maxBasisPointsFromPegLP)\n        public\n        override\n        onlyGovernor\n    {\n        require(\n            _maxBasisPointsFromPegLP <= BASIS_POINTS_GRANULARITY,\n            \"UniswapPCVDeposit: basis points from peg too high\"\n        );\n\n        uint256 oldMaxBasisPointsFromPegLP = maxBasisPointsFromPegLP;\n        maxBasisPointsFromPegLP = _maxBasisPointsFromPegLP;\n\n        emit MaxBasisPointsFromPegLPUpdate(\n            oldMaxBasisPointsFromPegLP,\n            _maxBasisPointsFromPegLP\n        );\n    }\n\n    /// @notice set the new pair contract\n    /// @param _pair the new pair\n    /// @dev also approves the router for the new pair token and underlying token\n    function setPair(address _pair) external override onlyGovernor {\n        _setupPair(_pair);\n\n        _approveToken(token);\n        _approveToken(_pair);\n    }\n\n    /// @notice returns total balance of PCV in the Deposit excluding the FEI\n    function balance() public view override returns (uint256) {\n        (, uint256 tokenReserves) = getReserves();\n        return _ratioOwned().mul(tokenReserves).asUint256();\n    }\n\n    /// @notice amount of pair liquidity owned by this contract\n    /// @return amount of LP tokens\n    function liquidityOwned() public view override returns (uint256) {\n        return pair.balanceOf(address(this));\n    }\n\n    function _removeLiquidity(uint256 liquidity) internal returns (uint256) {\n        uint256 endOfTime = type(uint256).max;\n        // No restrictions on withdrawal price\n        (, uint256 amountWithdrawn) =\n            router.removeLiquidity(\n                address(fei()),\n                token,\n                liquidity,\n                0,\n                0,\n                address(this),\n                endOfTime\n            );\n        return amountWithdrawn;\n    }\n\n    function _addLiquidity(uint256 tokenAmount, uint256 feiAmount) internal {\n        _mintFei(feiAmount);\n\n        uint256 endOfTime = type(uint256).max;\n        // Deposit price gated by slippage parameter\n        router.addLiquidity(\n            address(fei()),\n            token,\n            feiAmount,\n            tokenAmount,\n            _getMinLiquidity(feiAmount),\n            _getMinLiquidity(tokenAmount),\n            address(this),\n            endOfTime\n        );\n    }\n\n    /// @notice used as slippage protection when adding liquidity to the pool\n    function _getMinLiquidity(uint256 amount) internal view returns (uint256) {\n        return\n            (amount * (BASIS_POINTS_GRANULARITY - maxBasisPointsFromPegLP)) /\n            BASIS_POINTS_GRANULARITY;\n    }\n\n    /// @notice ratio of all pair liquidity owned by this contract\n    function _ratioOwned() internal view returns (Decimal.D256 memory) {\n        uint256 liquidity = liquidityOwned();\n        uint256 total = pair.totalSupply();\n        return Decimal.ratio(liquidity, total);\n    }\n\n    /// @notice approves a token for the router\n    function _approveToken(address _token) internal {\n        uint256 maxTokens = type(uint256).max;\n        IERC20(_token).approve(address(router), maxTokens);\n    }\n\n    // Wrap all held ETH\n    function _wrap() internal {\n        uint256 amount = address(this).balance;\n        IWETH(router.WETH()).deposit{value: amount}();\n    }\n}\n"
    },
    "contracts/pcv/uniswap/IUniswapPCVDeposit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../IPCVDeposit.sol\";\nimport \"../../external/uniswap/periphery/interfaces/IUniswapV2Router02.sol\";\n\n/// @title a PCV Deposit interface\n/// @author Fei Protocol\ninterface IUniswapPCVDeposit is IPCVDeposit {\n    // ----------- Events -----------\n\n    event MaxBasisPointsFromPegLPUpdate(uint256 oldMaxBasisPointsFromPegLP, uint256 newMaxBasisPointsFromPegLP);\n\n    // ----------- Governor only state changing api -----------\n\n    function setMaxBasisPointsFromPegLP(uint256 amount) external;\n\n    // ----------- Getters -----------\n\n    function router() external view returns (IUniswapV2Router02);\n\n    function liquidityOwned() external view returns (uint256);\n\n    function maxBasisPointsFromPegLP() external view returns (uint256);\n}\n\n"
    },
    "contracts/external/uniswap/periphery/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"
    },
    "contracts/external/uniswap/periphery/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/stabilizer/ReserveStabilizer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./IReserveStabilizer.sol\";\nimport \"../pcv/PCVDeposit.sol\";\nimport \"../refs/OracleRef.sol\";\nimport \"../openzeppelin/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title implementation for an ERC20 Reserve Stabilizer\n/// @author Fei Protocol\ncontract ReserveStabilizer is OracleRef, IReserveStabilizer, PCVDeposit {\n    using Decimal for Decimal.D256;\n\n    /// @notice the USD per FEI exchange rate denominated in basis points (1/10000)\n    uint256 public override usdPerFeiBasisPoints;\n    \n    /// @notice the denominator for basis granularity (10,000)\n    uint256 public constant BASIS_POINTS_GRANULARITY = 10_000;\n\n    /// @notice the ERC20 token exchanged on this stablizer\n    /// @dev left as 0x0 address for ETH and TRIBE stabilizers\n    IERC20 public token;\n\n    /// @notice ERC20 Reserve Stabilizer constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle the price oracle to reference\n    /// @param _backupOracle the backup oracle to reference\n    /// @param _token the ERC20 token for this stabilizer, 0x0 if TRIBE or ETH\n    /// @param _usdPerFeiBasisPoints the USD price per FEI to sell tokens at\n    constructor(\n        address _core,\n        address _oracle,\n        address _backupOracle,\n        IERC20 _token,\n        uint256 _usdPerFeiBasisPoints\n    ) OracleRef(\n        _core,\n        _oracle,\n        _backupOracle,\n        0, // default to zero for ETH and TRIBE which both have 18 decimals\n        true // invert the price oracle, as the operation performed here needs to convert FEI into underlying\n    ) {\n        require(_usdPerFeiBasisPoints <= BASIS_POINTS_GRANULARITY, \"ReserveStabilizer: Exceeds bp granularity\");\n        usdPerFeiBasisPoints = _usdPerFeiBasisPoints;\n        emit UsdPerFeiRateUpdate(0, _usdPerFeiBasisPoints);\n\n        token = _token;\n\n        if (address(_token) != address(0)) {\n            _setDecimalsNormalizerFromToken(address(_token));\n        }\n    }\n\n    /// @notice exchange FEI for tokens from the reserves\n    /// @param feiAmount of FEI to sell\n    function exchangeFei(uint256 feiAmount) public virtual override whenNotPaused returns (uint256 amountOut) {\n        updateOracle();\n\n        fei().burnFrom(msg.sender, feiAmount);\n\n        amountOut = getAmountOut(feiAmount);\n\n        _transfer(msg.sender, amountOut);\n        emit FeiExchange(msg.sender, feiAmount, amountOut);\n    }\n\n    /// @notice returns the amount out of tokens from the reserves for a given amount of FEI\n    /// @param amountFeiIn the amount of FEI in\n    function getAmountOut(uint256 amountFeiIn) public view override returns(uint256) {\n        uint256 adjustedAmountIn = amountFeiIn * usdPerFeiBasisPoints / BASIS_POINTS_GRANULARITY;\n        return readOracle().mul(adjustedAmountIn).asUint256();\n    }\n\n    /// @notice withdraw tokens from the reserves\n    /// @param to address to send tokens\n    /// @param amountOut amount of tokens to send\n    function withdraw(address to, uint256 amountOut) external virtual override onlyPCVController {\n        _transfer(to, amountOut);\n        emit Withdrawal(msg.sender, to, amountOut);\n    }\n\n    /// @notice new PCV deposited to the stabilizer\n    /// @dev no-op because the token transfer already happened\n    function deposit() external override virtual {}\n\n    /// @notice returns the amount of the held ERC-20\n    function balance() public view override virtual returns(uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice sets the USD per FEI exchange rate rate\n    /// @param newUsdPerFeiBasisPoints the USD per FEI exchange rate denominated in basis points (1/10000)\n    function setUsdPerFeiRate(uint256 newUsdPerFeiBasisPoints) external override onlyGovernor {\n        require(newUsdPerFeiBasisPoints <= BASIS_POINTS_GRANULARITY, \"ReserveStabilizer: Exceeds bp granularity\");\n        uint256 oldUsdPerFeiBasisPoints = usdPerFeiBasisPoints;\n        usdPerFeiBasisPoints = newUsdPerFeiBasisPoints;\n        emit UsdPerFeiRateUpdate(oldUsdPerFeiBasisPoints, newUsdPerFeiBasisPoints);\n    }\n\n    function _transfer(address to, uint256 amount) internal virtual {\n        SafeERC20.safeTransfer(IERC20(token), to, amount);\n    }\n}\n"
    },
    "contracts/stabilizer/IReserveStabilizer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\n/// @title a Reserve Stabilizer interface\n/// @author Fei Protocol\ninterface IReserveStabilizer {\n\n    // ----------- Events -----------\n    event FeiExchange(address indexed to, uint256 feiAmountIn, uint256 amountOut);\n\n    event UsdPerFeiRateUpdate(uint256 oldUsdPerFeiBasisPoints, uint256 newUsdPerFeiBasisPoints);\n\n    // ----------- State changing api -----------\n\n    function exchangeFei(uint256 feiAmount) external returns (uint256);\n\n    // ----------- Governor only state changing api -----------\n\n    function setUsdPerFeiRate(uint256 exchangeRateBasisPoints) external;\n\n    // ----------- Getters -----------\n\n    function usdPerFeiBasisPoints() external view returns (uint256);\n\n    function getAmountOut(uint256 amountIn) external view returns (uint256);\n}\n"
    },
    "contracts/openzeppelin/governance/extensions/GovernorVotesComp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../token/ERC20/extensions/ERC20VotesComp.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from a Comp token.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotesComp is Governor {\n    ERC20VotesComp public immutable token;\n\n    constructor(ERC20VotesComp token_) {\n        token = token_;\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {IGovernor-getVotes}).\n     */\n    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        return token.getPriorVotes(account, blockNumber);\n    }\n}\n"
    },
    "contracts/openzeppelin/token/ERC20/extensions/ERC20VotesComp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20Votes.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound's voting and delegation. This version exactly matches Compound's\n * interface, with the drawback of only supporting supply up to (2^96^ - 1).\n *\n * NOTE: You should use this contract if you need exact compatibility with COMP (for example in order to use your token\n * with Governor Alpha or Bravo) and if you are sure the supply cap of 2^96^ is enough for you. Otherwise, use the\n * {ERC20Votes} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getCurrentVotes} and {getPriorVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this\n * will significantly increase the base gas cost of transfers.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesComp is ERC20Votes {\n    /**\n     * @dev Comp version of the {getVotes} accessor, with `uint96` return type.\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        return SafeCast.toUint96(getVotes(account));\n    }\n\n    /**\n     * @dev Comp version of the {getPastVotes} accessor, with `uint96` return type.\n     */\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {\n        return SafeCast.toUint96(getPastVotes(account, blockNumber));\n    }\n\n    /**\n     * @dev Maximum token supply. Reduced to `type(uint96).max` (2^96^ - 1) to fit COMP interface.\n     */\n    function _maxSupply() internal view virtual override returns (uint224) {\n        return type(uint96).max;\n    }\n}"
    },
    "contracts/dao/DohrniiGovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"../openzeppelin/governance/Governor.sol\";\nimport \"../openzeppelin/governance/compatibility/GovernorCompatibilityBravo.sol\";\nimport \"../openzeppelin/governance/extensions/GovernorVotesComp.sol\";\nimport \"../openzeppelin/governance/extensions/GovernorTimelockControl.sol\";\n\n\ncontract DohrniiGovernorAlpha is Governor, GovernorCompatibilityBravo, GovernorVotesComp, GovernorTimelockControl {\n    constructor(ERC20VotesComp _token, TimelockController _timelock)\n        Governor(\"Dohrnii Governor Alpha\")\n        GovernorVotesComp(_token)\n        GovernorTimelockControl(_timelock)\n    {}\n\n    function votingDelay() public pure override returns (uint256) {\n        return 1; // 1 block\n    }\n\n    function votingPeriod() public pure override returns (uint256) {\n        return 201600; // 1 week\n    }\n\n    function quorum(uint256 blockNumber) public pure override returns (uint256) {\n        return 4e18;\n    }\n\n    function proposalThreshold() public pure override returns (uint256) {\n        return 1e18;\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function getVotes(address account, uint256 blockNumber)\n        public\n        view\n        override(IGovernor, GovernorVotesComp)\n        returns (uint256)\n    {\n        return super.getVotes(account, blockNumber);\n    }\n\n    function state(uint256 proposalId)\n        public\n        view\n        override(Governor, IGovernor, GovernorTimelockControl)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description)\n        public\n        override(Governor, GovernorCompatibilityBravo, IGovernor)\n        returns (uint256)\n    {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function _execute(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n        internal\n        override(Governor, GovernorTimelockControl)\n    {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)\n        internal\n        override(Governor, GovernorTimelockControl)\n        returns (uint256)\n    {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor()\n        internal\n        view\n        override(Governor, GovernorTimelockControl)\n        returns (address)\n    {\n        return super._executor();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(Governor, IERC165, GovernorTimelockControl)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}"
    },
    "contracts/pcv/utils/ERC20Dripper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./../PCVDeposit.sol\";\nimport \"./../../utils/Timed.sol\";\n\ncontract ERC20Dripper is PCVDeposit, Timed {\n    using Address for address payable;\n\n    /// @notice event emitted when tokens are dripped\n    event Dripped(uint256 amount);\n\n    /// @notice target address to drip tokens to\n    address public target;\n    /// @notice target token address to send\n    address public token;\n    /// @notice amount to drip after each window\n    uint256 public amountToDrip;\n\n\n    /// @notice ERC20 PCV Dripper constructor\n    /// @param _core Fei Core for reference\n    /// @param _target address to drip to\n    /// @param _frequency frequency of dripping\n    /// @param _amountToDrip amount to drip on each drip\n    /// @param _token amount to drip on each drip\n    constructor(\n        address _core,\n        address _target,\n        uint256 _frequency,\n        uint256 _amountToDrip,\n        address _token\n    ) CoreRef(_core) Timed(_frequency) {\n        require(_target != address(0), \"ERC20Dripper: invalid address\");\n        require(_token != address(0), \"ERC20Dripper: invalid token address\");\n        require(_amountToDrip > 0, \"ERC20Dripper: invalid drip amount\");\n\n        target = _target;\n        amountToDrip = _amountToDrip;\n        token = _token;\n\n        // start timer\n        _initTimed();\n    }\n \n    /// @notice drip ERC20 tokens to target\n    function drip()\n       external\n       afterTime\n       whenNotPaused\n    {\n        // reset timer\n        _initTimed();\n\n        // drip\n        _withdrawERC20(token, target, amountToDrip);\n        emit Dripped(amountToDrip);\n    }\n\n    /// @notice withdraw tokens from the PCV allocation\n    /// @param amountUnderlying of tokens withdrawn\n    /// @param to the address to send PCV to\n    function withdraw(address to, uint256 amountUnderlying)\n        external\n        override\n        onlyPCVController\n    {\n        _withdrawERC20(address(token), to, amountUnderlying);\n    }\n\n    /// @notice no-op\n    function deposit() external override {}\n\n    /// @notice returns total balance of PCV in the Deposit\n    function balance() public view override returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n}"
    },
    "contracts/pcv/snapshot/SnapshotDelegatorPCVDeposit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../PCVDeposit.sol\";\n\ninterface DelegateRegistry {\n    function setDelegate(bytes32 id, address delegate) external;\n\n    function clearDelegate(bytes32 id) external;\n\n    function delegation(address delegator, bytes32 id) external view returns(address delegatee);\n}\n\n/// @title Snapshot Delegator PCV Deposit\n/// @author Fei Protocol\ncontract SnapshotDelegatorPCVDeposit is PCVDeposit {\n\n    event DelegateUpdate(address indexed oldDelegate, address indexed newDelegate);\n\n    /// @notice the Gnosis delegate registry used by snapshot\n    DelegateRegistry public constant DELEGATE_REGISTRY = DelegateRegistry(0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446);\n    \n    /// @notice the token that is being used for snapshot\n    IERC20 public immutable token;\n\n    /// @notice the keccak encoded spaceId of the snapshot space\n    bytes32 public spaceId;\n    \n    /// @notice the snapshot delegate for the deposit\n    address public delegate;\n\n    /// @notice Snapshot Delegator PCV Deposit constructor\n    /// @param _core Fei Core for reference\n    /// @param _token snapshot token\n    /// @param _spaceId the id (or ENS name) of the snapshot space\n    constructor(\n        address _core,\n        IERC20 _token,\n        bytes32 _spaceId,\n        address _initialDelegate\n    ) CoreRef(_core) {\n        token = _token;\n        spaceId = _spaceId;\n        _delegate(_initialDelegate);\n    }\n\n    /// @notice withdraw tokens from the PCV allocation\n    /// @param amountUnderlying of tokens withdrawn\n    /// @param to the address to send PCV to\n    function withdraw(address to, uint256 amountUnderlying)\n        external\n        override\n        onlyPCVController\n    {\n        _withdrawERC20(address(token), to, amountUnderlying);\n    }\n\n    /// @notice no-op\n    function deposit() external override {}\n\n    /// @notice returns total balance of PCV in the Deposit\n    function balance() public view override returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice sets the snapshot delegate\n    /// @dev callable by governor or admin\n    function setDelegate(address newDelegate) external onlyGovernorOrAdmin {\n        _delegate(newDelegate);\n    }\n\n    /// @notice clears the delegate from snapshot\n    /// @dev callable by governor or guardian\n    function clearDelegate() external onlyGuardianOrGovernor {\n        address oldDelegate = delegate;\n        DELEGATE_REGISTRY.clearDelegate(spaceId);\n\n        emit DelegateUpdate(oldDelegate, address(0));\n    }\n\n    function _delegate(address newDelegate) internal {\n        address oldDelegate = delegate;\n        DELEGATE_REGISTRY.setDelegate(spaceId, newDelegate);\n        delegate = newDelegate;\n\n        emit DelegateUpdate(oldDelegate, newDelegate);\n    }\n}\n"
    },
    "contracts/stabilizer/EthReserveStabilizer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./ReserveStabilizer.sol\";\nimport \"../external/uniswap/periphery/interfaces/IWETH.sol\";\n\n/// @title implementation for an ETH Reserve Stabilizer\n/// @author Fei Protocol\ncontract EthReserveStabilizer is ReserveStabilizer {\n\n    /// @notice wrapped ETH address\n    address public immutable WETH;\n\n    /// @notice ETH Reserve Stabilizer constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle the ETH price oracle to reference\n    /// @param _backupOracle the backup oracle to reference\n    /// @param _usdPerFeiBasisPoints the USD price per FEI to sell ETH at\n    constructor(\n        address _core,\n        address _oracle,\n        address _backupOracle,\n        uint256 _usdPerFeiBasisPoints,\n        address _WETH\n    ) ReserveStabilizer(_core, _oracle, _backupOracle, IERC20(address(0)), _usdPerFeiBasisPoints) {\n        WETH = _WETH;\n    }\n\n    receive() external payable {}\n\n    /// @notice unwraps any held WETH\n    function deposit() external override {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        if (wethBalance != 0) {\n            IWETH(WETH).withdraw(wethBalance);\n        }\n    }\n\n    /// @notice returns the amount of the held ETH\n    function balance() public view override returns(uint256) {\n        return address(this).balance;\n    }\n\n    function _transfer(address to, uint256 amount) internal override {\n        Address.sendValue(payable(to), amount);\n    }\n}\n"
    },
    "contracts/oracle/IUniswapOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../external/uniswap/core/interfaces/IUniswapV2Pair.sol\";\nimport \"./IOracle.sol\";\n\n/// @title Uniswap oracle interface\n/// @author Fei Protocol\ninterface IUniswapOracle is IOracle {\n    // ----------- Events -----------\n    event TWAPDurationUpdate(uint256 _duration);\n\n    // ----------- Governor only state changing API -----------\n\n    function setDuration(uint256 _duration) external;\n\n    // ----------- Getters -----------\n\n    function priorTimestamp() external returns (uint32);\n\n    function priorCumulative() external returns (uint256);\n\n    function duration() external returns (uint256);\n\n    function pair() external returns (IUniswapV2Pair);\n}\n"
    },
    "contracts/oracle/UniswapOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\n// Referencing Uniswap Example Simple Oracle\n// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\n\nimport \"./IUniswapOracle.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../external/UniswapV2OracleLibrary.sol\";\n\n/// @title Uniswap Oracle for ETH/USDC\n/// @author Fei Protocol\n/// @notice maintains the TWAP of a uniswap pair contract over a specified duration\ncontract UniswapOracle is IUniswapOracle, CoreRef {\n    using Decimal for Decimal.D256;\n\n    /// @notice the referenced uniswap pair contract\n    IUniswapV2Pair public override pair;\n    bool private isPrice0;\n\n    /// @notice the previous cumulative price of the oracle snapshot\n    uint256 public override priorCumulative;\n\n    /// @notice the previous timestamp of the oracle snapshot\n    uint32 public override priorTimestamp;\n\n    Decimal.D256 private twap = Decimal.zero();\n\n    /// @notice the window over which the initial price will \"thaw\" to the true peg price\n    uint256 public override duration;\n\n    uint256 private constant FIXED_POINT_GRANULARITY = 2**112;\n    uint256 private constant USDC_DECIMALS_MULTIPLIER = 1e12; // to normalize USDC and ETH wei units\n\n    /// @notice UniswapOracle constructor\n    /// @param _core Fei Core for reference\n    /// @param _pair Uniswap Pair to provide TWAP\n    /// @param _duration TWAP duration\n    /// @param _isPrice0 flag for using token0 or token1 for cumulative on Uniswap\n    constructor(\n        address _core,\n        address _pair,\n        uint256 _duration,\n        bool _isPrice0\n    ) CoreRef(_core) {\n        pair = IUniswapV2Pair(_pair);\n        // Relative to USD per ETH price\n        isPrice0 = _isPrice0;\n\n        duration = _duration;\n\n        _init();\n    }\n\n    /// @notice updates the oracle price\n    function update() external override whenNotPaused {\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint32 currentTimestamp\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        uint32 deltaTimestamp;\n        unchecked {\n            deltaTimestamp = currentTimestamp - priorTimestamp; // allowing underflow per Uniswap Oracle spec\n        }\n\n        if (deltaTimestamp < duration) {\n            return;\n        }\n\n        uint256 currentCumulative = _getCumulative(price0Cumulative, price1Cumulative);\n        \n        uint256 deltaCumulative;\n        unchecked {\n            deltaCumulative = (currentCumulative - priorCumulative); // allowing underflow per Uniswap Oracle spec\n        }\n        deltaCumulative = deltaCumulative * USDC_DECIMALS_MULTIPLIER; \n\n        // Uniswap stores cumulative price variables as a fixed point 112x112 so we need to divide out the granularity\n        Decimal.D256 memory _twap =\n            Decimal.ratio(\n                deltaCumulative / deltaTimestamp,\n                FIXED_POINT_GRANULARITY\n            );\n        twap = _twap;\n\n        priorTimestamp = currentTimestamp;\n        priorCumulative = currentCumulative;\n\n        emit Update(_twap.asUint256());\n    }\n\n    /// @notice determine if read value is stale\n    /// @return true if read value is stale\n    function isOutdated() external view override returns (bool) {\n        (, , uint32 currentTimestamp) =\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n        uint32 deltaTimestamp = currentTimestamp - priorTimestamp; // allowing underflow per Uniswap Oracle spec\n        return deltaTimestamp >= duration;\n    }\n\n    /// @notice read the oracle price\n    /// @return oracle price\n    /// @return true if price is valid\n    /// @dev price is to be denominated in USD per X where X can be ETH, etc.\n    /// @dev Can be innacurate if outdated, need to call `isOutdated()` to check\n    function read() external view override returns (Decimal.D256 memory, bool) {\n        bool valid = !(paused() || twap.isZero());\n        return (twap, valid);\n    }\n\n    /// @notice set a new duration for the TWAP window\n    function setDuration(uint256 _duration) external override onlyGovernor {\n        require(_duration != 0, \"UniswapOracle: zero duration\");\n\n        duration = _duration;\n        emit TWAPDurationUpdate(_duration);\n    }\n\n    function _init() internal {\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint32 currentTimestamp\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        priorTimestamp = currentTimestamp;\n        priorCumulative = _getCumulative(price0Cumulative, price1Cumulative);\n    }\n\n    function _getCumulative(uint256 price0Cumulative, uint256 price1Cumulative)\n        internal\n        view\n        returns (uint256)\n    {\n        return isPrice0 ? price0Cumulative : price1Cumulative;\n    }\n}\n"
    },
    "contracts/external/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nimport \"./uniswap/core/interfaces/IUniswapV2Pair.sol\";\nimport \"./uniswap/libraries/FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            unchecked {\n                // subtraction overflow is desired\n                uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n                // addition overflow is desired\n                // counterfactual\n                price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n                // counterfactual\n                price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n            }\n        }\n    }\n}"
    },
    "contracts/external/uniswap/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.4.0;\n\nimport './FullMath.sol';\nimport './Babylonian.sol';\nimport './BitMath.sol';\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 public constant RESOLUTION = 112;\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\n        return uq144x112(z);\n    }\n\n    // multiply a UQ112x112 by an int and decode, returning an int\n    // reverts on overflow\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n        require(z < 2**255, 'FixedPoint::muli: overflow');\n        return y < 0 ? -int256(z) : int256(z);\n    }\n\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n    // lossy\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        if (self._x == 0 || other._x == 0) {\n            return uq112x112(0);\n        }\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n\n        // partial products\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n        // so the bit shift does not overflow\n        require(upper <=  type(uint112).max, 'FixedPoint::muluq: upper overflow');\n\n        // this cannot exceed 256 bits, all values are 224 bits\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n\n        // so the cast does not overflow\n        require(sum <= type(uint224).max, 'FixedPoint::muluq: sum overflow');\n\n        return uq112x112(uint224(sum));\n    }\n\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        require(other._x > 0, 'FixedPoint::divuq: division by zero');\n        if (self._x == other._x) {\n            return uq112x112(uint224(Q112));\n        }\n        if (self._x <= type(uint144).max) {\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n            require(value <= type(uint224).max, 'FixedPoint::divuq: overflow');\n            return uq112x112(uint224(value));\n        }\n\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n        require(result <= type(uint224).max, 'FixedPoint::divuq: overflow');\n        return uq112x112(uint224(result));\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // can be lossy\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= type(uint144).max) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= type(uint224).max, 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= type(uint224).max , 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        }\n    }\n\n    // take the reciprocal of a UQ112x112\n    // reverts on overflow\n    // lossy\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\n        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        if (self._x <= type(uint144).max )  {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n    }\n}\n"
    },
    "contracts/external/uniswap/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: CC-BY-4.0\npragma solidity >=0.4.0;\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, type(uint256).max);\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & (~d+1);\n        d /= pow2;\n        l /= pow2;\n        l += h * ((~pow2+1) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n\n        if (h == 0) return l / d;\n\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\n        return fullDiv(l, h, d);\n    }\n}\n"
    },
    "contracts/external/uniswap/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nlibrary BitMath {\n    // returns the 0 indexed position of the most significant bit of the input x\n    // s.t. x >= 2**msb and x < 2**(msb+1)\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    // returns the 0 indexed position of the least significant bit of the input x\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::leastSignificantBit: zero');\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x &  type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint8).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}"
    },
    "contracts/oracle/CompositeOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../refs/CoreRef.sol\";\nimport \"./IOracle.sol\";\n\n/// @title A composite oracle\n/// @author Fei Protocol\n/// @notice Reads two oracles and returns their product\ncontract CompositeOracle is IOracle, CoreRef {\n    using Decimal for Decimal.D256;\n\n    /// @notice the first referenced oracle\n    IOracle public oracleA;\n    /// @notice the second referenced oracle\n    IOracle public oracleB;\n\n    /// @notice CompositeOracle constructor\n    /// @param _oracleA first referenced oracle\n    /// @param _oracleB second referenced oracle\n    constructor(\n        address _core,\n        IOracle _oracleA,\n        IOracle _oracleB\n    ) CoreRef(_core) {\n        oracleA = _oracleA;\n        oracleB = _oracleB;\n    }\n\n    /// @notice updates the oracle price\n    function update() external override whenNotPaused {\n        oracleA.update();\n        oracleB.update();\n    }\n\n    /// @notice determine if read value is stale\n    /// @return true if read value is stale\n    function isOutdated() external view override returns (bool) {\n        return oracleA.isOutdated() || oracleB.isOutdated();\n    }\n\n    /// @notice read the oracle price\n    /// @return oracle price\n    /// @return true if price is valid\n    function read() external view override returns (Decimal.D256 memory, bool) {\n\n        (Decimal.D256 memory priceA, bool validA) = oracleA.read();\n        (Decimal.D256 memory priceB, bool validB) = oracleB.read();\n        bool valid = !paused() && validA && validB;\n\n        return (priceA.mul(priceB), valid);\n    }\n}\n"
    },
    "contracts/oracle/ChainlinkOracleWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./IOracle.sol\";\nimport \"../refs/CoreRef.sol\";\nimport \"../external/chainlink/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/// @title Chainlink oracle wrapper\n/// @author eswak\n/// @notice Reads a Chainlink oracle value & wrap it under the standard Fei oracle interface\ncontract ChainlinkOracleWrapper is IOracle, CoreRef {\n    using Decimal for Decimal.D256;\n\n    /// @notice the referenced chainlink oracle\n    AggregatorV3Interface public chainlinkOracle;\n    uint256 public oracleDecimalsNormalizer;\n\n    /// @notice ChainlinkOracleWrapper constructor\n    /// @param _core Fei Core for reference\n    /// @param _chainlinkOracle reference to the target Chainlink oracle\n    constructor(\n        address _core,\n        address _chainlinkOracle\n    ) CoreRef(_core) {\n        chainlinkOracle = AggregatorV3Interface(_chainlinkOracle);\n\n        _init();\n    }\n\n    // @dev: decimals of the oracle are expected to never change, if Chainlink\n    // updates that behavior in the future, we might consider reading the\n    // oracle decimals() on every read() call.\n    function _init() internal {\n        uint8 oracleDecimals = chainlinkOracle.decimals();\n        oracleDecimalsNormalizer = 10 ** uint256(oracleDecimals);\n    }\n\n    /// @notice updates the oracle price\n    /// @dev no-op, Chainlink is updated automatically\n    function update() external view override whenNotPaused {}\n\n    /// @notice determine if read value is stale\n    /// @return true if read value is stale\n    function isOutdated() external view override returns (bool) {\n        (uint80 roundId,,,, uint80 answeredInRound) = chainlinkOracle.latestRoundData();\n        return answeredInRound != roundId;\n    }\n\n    /// @notice read the oracle price\n    /// @return oracle price\n    /// @return true if price is valid\n    function read() external view override returns (Decimal.D256 memory, bool) {\n        (uint80 roundId, int256 price,,, uint80 answeredInRound) = chainlinkOracle.latestRoundData();\n        bool valid = !paused() && price > 0 && answeredInRound == roundId;\n\n        Decimal.D256 memory value = Decimal.from(uint256(price)).div(oracleDecimalsNormalizer);\n        return (value, valid);\n    }\n}\n"
    },
    "contracts/external/chainlink/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}